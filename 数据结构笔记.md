# 第一章：绪论



## 重点：

- 逻辑、存储结构的基本概念，有哪些

- 时间复杂度




### 1.1.1  基本概念：

**数据元素**： 是数据的基本单位，通常作为一个整体，一个数据元素由若干个 **数据项** 组成，数据项最小不可分割。**数据对象** 是有相同性质的数据元素的集合。

**数据类型**：

- 原子类型：不可分割
- 结构类型：可分割
- **抽象数据类型（ADT）** ：可以用来定义一个完整的数据结构。包括数据元素、数据对象、数据关系

**数据结构：** 存在一种或者多种特定关系的数据元素的集合，包括：

- 逻辑结构
- 存储结构
- 数据的运算



<hr>



### 1.1.2  逻辑结构和存储结构

**逻辑结构：**

 和存储无关，独立于计算机

- 线性结构（只存在一对一的关系）：线性表、受限的线性表（栈、队列、串）
- 非线性结构（存在一对多的关系）：树、图、集合



**存储结构**：

物理结构，依赖于语言

- 顺序存储：逻辑上相邻，物理也相邻。优：随机存取。缺：外部碎片
- 链式存储：用指针。优：无碎片。缺：只能顺序存取
- 索引存储：索引表。优：速度快。缺：索引表额外开销
- 散列存储：用关键字计算出地址。优：查增删都快。缺：冲突的开销



**数据的运算**：

**设计** 取决于 **逻辑结构** ，**实现** 取决于 **存储结构**



**算法的五个重要特征**：

- 有穷性
- 确定性
- 可行性
- 输入
- 输出



# 第二章：线性表

## 重点：

- 两种存储结构的基本操作、思想
- 相关算法的实现



### 2.1.1 定义：

线性表是 **逻辑结构**  ，是具有相同数据类型的n个（n>0）数据元素的有限序列，n=0时为空表。

**顺序表** 、 **链表** （包括邻接表）是 **存储结构** ，是线性表的顺序存储和链式存储



**特点：**

1. 由 **相同数据类型** 的 **数据元素** 组成（数据元素由数据项组成）
2. 逻辑上 **有先后次序** 
3.  **有限** 序列
4.  **抽象性** 



---

<br>



## 2.2 顺序表

**顺序表是线性表的顺序存储** 

用一组 **地址连续的存储单元** 依次存储线性表中的数据元素， **逻辑上相邻在物理上也相邻** ，联想到 **数组** （但也并非都是静态的，例如vector）

注意：线性表中元素的 **位序** 从1开始，数组中下标从0开始

**优点：**

- 线性表中元素的顺序和逻辑有关，能 **随机存取** ，时间复杂度为O(1)
- 存储密度高

**缺点**

- 插入和删除需要移动大量元素，插入和删除本身O(1)，移动元素O(n)，因此整个过程是O(n)

按值查找的平均时间复杂度：O(n)



### 习题：

#### 选择题：

1. 若线性表常用操作是存取第i个元素及其前驱和后继元素的值，为了提高效率，应采用： **顺序表**

   错选 **双向链表**  ，顺序表取第i、i-1、i+1的元素都是O(1)。双向链表还是得从头依次查找，需要O(n)

#### 应用题：

1. 【2010】设将n（n>1）个整数存放到一维数组R中。设计一个时间和空间都尽可能高效的算法，将R中保存的序列循环左移P（0<p<n）个位置，并说明时间复杂度和空间复杂度。

   

   ```c++
   /*
   描述：
   可理解为将数组ab转换成数组ba。
   先将a转置，得到：a-1b
   再将b转置，得到：a-1b-1
   最后再整体转置，得到 ba
   */
       
   // 反转l到r区间内的元素 
   void reverse(int a[], int l, int r){
   	int tmp;
   	for(int i = 0; i < (r - l + 1) / 2; i ++ ){
   		tmp = a[l + i];
   		a[l + i] = a[r - i];
   		a[r - i] = tmp; 
   	}
   }
   
   int main(){
   	int p = 3, n = 8;
   	
   	reverse(a, 0, p-1);	//3 2 1 4 5 6 7 8 
   	reverse(a, p, n-1); // 3 2 1 8 7 6 5 4
   	reverse(a, 0, n-1); // 4 5 6 7 8 1 2 3
   }
   
   /*
   时间复杂度：O(n) 3次转置, 每次O(n)
   空间复杂度：O(1) 只用了临时变量tmp
   */
   ```

   

2. 【2018】给定一个含n(n>=1)个整数的数组，请设计一个时间上尽可能高效的算法，找出数组中未出现的最小正整数。例如{-5，3， 2， 3}中未出现的最小正整数是1；数组{1，2，3}中未出现的最小正整数是4。要求：

   1）给出算法的基本设计思想

   2）用c/c++描述，关键处给注释

   3）说明复杂度

   

   ```c++
   /*
   描述：
   数组中只有n个元素。如果元素都在1~n中,那么结果就是n+1。如果元素有不在1~n中，那么结果一定在1~n当中。
   用一个数组B[n+1]来记录1~n是否出现过。最后遍历B[n],找到第一个为出现过得数即可。如果遍历完,返回n+1即可
   */
   
   int findMissMin(int A[], int n){
       vector<int> B(n);
       int i;
       
       for(i = 0; i < n; i++ )
           if(A[i] > 0 && A[i] <= n)
               B[A[i] - 1] = 1;	//在1~n中就进行标记
       for(i = 0; i < n; i++ )
           if(B[i] == 0)
               break;
       return i + 1;
   }
   
   /*
   时间复杂度：O(n)，遍历两次
   空间复杂度：O(n),辅助数组B[n]
   */
   ```

   

3. 【2020】定义三元组(a，b，c)（均为正数）的距离D=|a-b| + |b-c| + |c-a|。给定3个非空整数集合S1，S2， S3按升序分别存储在3个数组中。设计一个尽可能高效的算法，计算并输出所有可能的三元组(a，b，c)中的最小距离。例如S1={-1，0，9}，S2={-25，-10，10，11}，S3={2，9，17，30，41}则最小距离2，相应的三元组为{9，10，9}。要求：

   1）给出算法的基本设计思想

   2）用c/c++描述，关键处给注释

   3）说明复杂度

   

   ```c++
   /*
   分析：
   a=b=c时,有D最小
   其余情况下(假设 a<=b<=c): D=2 * |c-a|
   因此问题可以简化为找|c-a|最小,每次更新3元组中最小的a即可
   
   描述：
   用Dmin记录当前的最小距离。初值赋一个足够大的整数
   每次计算当前的D，如果比Dmin小，就更新
   每次找到3元组中最小元素，将它的下标+1
   */
   
   // 判断a是否是三个数中的最小值
   bool judge_min(int a, int b, int c){
       if(a <= b && a <= c) return true;
       return false;
   }
   
   // ABC存放3个结合中的元素 nmp为三个集合的大小
   int findMinD(int A[], int n, int B[], int m, int C[], int p){
       int i = 0, j = 0, k = 0, Dmin = INT_MAX, D;
       while(i < n && j < m && k < p && Dmin > 0){
           D = abs(A[i] - B[j]) + abs(B[j] - C[k]) + abs(C[k] - A[i]); //计算D
           if(D < Dmin) Dmin = D;  //更新Dmin
           // 将A[i],B[j],C[k]中最小值的下标+1
           if(judge_min(A[i], B[j], C[k])) i++;
           else if(judge_min(B[j], C[k], A[i])) j++;
           else k++;
       }
       return Dmin;
   }
   
   /*
   时间复杂度：O(n)
   空间复杂度：O(1)
   */
   ```



## 2.3 链表：

线性表的链式存储，不需要连续的存储单元、插入和删除不需要移动元素，只需要修改指针。不能随机存取

### 2.3.1 单链表

**优点：**

- 不需要连续的存储单元
- 插入和删除不需要移动元素

**缺点：**

- 每个结点带指针域，浪费空间
- 不能实现随机存取，查找时需要从头遍历

一般用 **头指针** 来标识一个链表，头指针为NULL表示空表

**引入头结点h：**
头结点的指针域指向第一个元素结点，指针域为NULL表示空表
注意： 带头节点的单链表表长不包括头结点

**引入头节点后的优点：**

- 统一了第一个结点和其他结点的操作，第一个结点不需要单独处理
- 统一了空表和非空表的操作

**引入尾指针r：**

尾指针r始终指向当前链表的尾结点





### 2.3.2 单链表的基本操作：

#### 头插法： 

```C++
int x;

LNode s = new LNode();	//创建结点
s->data = x;
s->next = L->next;
L->next = s;
```

读入数据的顺序和链表中的元素数据 **相反** 



#### 尾插法： 

需要 **尾指针** 

```C++
int x;

LNode s = new LNode();	//创建新结点
s->data = x;
r->next = s;
r = s;
r->next = NULL;	//尾指针置空
```

读入数据的顺序和链表中的元素数据 **相同**

采用头插法或者尾插法来构建链表时，插入一个元素O(1)，总共O(n) 



#### 插入结点：



```c++
// 将结点s插入到p和q之间 时间复杂度O(1)
s->next = p->next;
p-next = s;

// 将值为x的新结点插入到链表第i个位置 时间复杂度O(n)
LNode s = new LNode(); //创建新结点
s->data = x;
p = GetElem(L, i-1); //查找插入位置的前驱结点
s->next = p->next;
p-next = s;

// 对某一结点进行前插操作：对i前插 = 对i-1后插 时间复杂度O(n)
```



#### 按序号查找：

```c++
LNode *GetElemByIndex(LinkList L, int i){
	int j = 1;
    LNode *p = L->next;	//p为第一个结点的指针
    if(i < 1) return NULL; // 无效返回NULL
    while(p && j < i){
        p = p->next;
        j++;
    }
    return p;	//返回第i个结点的指针
}
```



#### 按值查找：

```c++
LNode *GetElemByValue(LinkList L, ElemType e){
	LNode *p = L->next;	//p为第一个结点的指针
    while(p != NULL && p->data != e)
        p = p->next;
   	return p;
}
```

单链表需要从头遍历，因此不管是按序号查找还是按值查找，时间复杂度都是 **O(n)** 



#### 删除结点:

```c++
// 删除第i个结点
p = GetElem(L, i-1); // 找到删除位置的前驱结点
q = p->next; // q指向被删除结点
p->next = q->next;
free(q);
```

删除不需要移动元素，删除O(1)，查找位置O(n)



#### 求表长：

从头遍历计数即可



# 第三章：栈、队列和数组



## 重点

- 基本概念：栈、循环队列

- 选择题：出入栈过程、合法性

- 数组、特殊矩阵的压缩存储



## 3.1 栈

栈（stack）是输入输出受限制的线性表。只允许在 **栈顶（Top）** 进行插入和删除。

栈的特性为 **后进先出（LIFO）** 

栈的数学性质：

- **卡特兰（Catalan）数** ：n个不同元素进栈，出栈元素的不同排列有： $\frac{1}{n+1}C_{2n}^{n}$

  



<br>

### 3.1.2 顺序栈

用一组地址连续的存储单元存放 **从栈底到栈顶** 的元素，同时用一个 指针top 指向当前的栈顶元素（若为指向栈顶的下一个元素，需要灵活变化）

```c++
#define Maxsize 50
typedef struct{
	Elemtype data[MaxSize];	// 存放元素
	int top;	// 栈顶指针
}SqStack;	// 顺序栈
```



- 初始化： `S.top = -1` ；栈顶元素 `S.data[S.top]` 

- 进栈：当栈不满时，指针先+1，在赋值给栈顶 `S.data[++S.top]`
- 出栈：当栈不空时，先取值，指针再-1 `S.data[S.top--]`
- 栈空条件：`S.top == -1`
- 栈满条件：`S.top == MaxSize - 1`



 **注意：** 栈满还入是上溢，栈空还取是下溢

<br>

#### 共享栈

让两个顺序栈共享一个一维数组的空间，两个栈底分别在数组的两段，栈顶向中间延伸。

 **特点** ：能更有效地利用存储空间，不容易上溢。但存取效率没影响

<br>

### 3.1.3 链栈

通常用 **单链表** 实现，规定所有的操作均在 **表头** 进行（对于带不带头结点的操作要灵活处理）

优点：

- 便于结点的插入删除
- 便于多个栈共享存储空间和提高效率
- 不存在栈满上溢

<br>

### 习题

 **选择题** ：

1. 栈和队列有相同的 **逻辑结构** 

   只是运算不同，实际上都是 **线性表** 

2. 采用非递归方式重写递归程序必须用到栈（ **错误** 

    **反例** ：计算斐波那锲数列迭代实现只需要一个循环

3. 函数调用时，系统用栈保存必要的信息（ **正确** 

 **应用题** ：

1. 假设以I和O表示入栈和出栈。栈的初试和终态均为空，如果I和O组成的序列合法成为合法序列，否则非法。

   写出一个算法，判断给出的操作序列是否合法。

   ```c++
   /*
   一次扫描出入栈序列
   每次检查出栈次数是否大于入栈序列, 大于则非法
   扫描结束检查入栈和出栈次数是否相等，不等则非法
   */
   
   bool judge(char A[]){
       // i 下标 jk为入栈和出栈的次数
       int i = j = k = 0;
       
       while(A[i] != '\0'){
           switch(A[i]){
               case 'I': 
                   j++; 
                   break;
               case 'O': 
                   k++;
                   if(k > j) return false;
           }
           i++;
       }
       if(j != k)  return false;
       return true;
   } 
   ```

   

2. 设单链表表头指针为L，结点结构由data和next两个域组成，其中data是字符型。设计算法判断该链表的全部n个字符是否中心对称。

   例如 `xyx` 、 `xyyx` 都是中心对称。

   ```c++
   /*
   前一半元素入栈，然后依次访问后半元素，每次栈中弹出一个, 对比, 直到链表尾
   */
   
   bool judge(LinkList L, int n){
       int i = 0;
       char s[n/2];    // 字符栈
       p = L->next;    // p指向当前处理的元素
       for(i = 0; i < n / 2; i++ ){
           s[i] = p->data;
           p=p->next;
       }
       i--;    //恢复i的值
       if(n % 2 == 1)  p = p->next;    //是奇数就往后移动一位
       while(p != NULL && s[i] == p->data){
           i--;    // i充当栈顶指针
           p=p->next;
       }
       if(i == -1) return true;
       return false;
   } 
   ```

   

3. 设有两个栈s1、s2共享一个存储区 `[0,…,maxsize-1]` 来构建 **共享栈** 。试设计s1、s2关于入栈和出栈的操作算法。

   ```c++
   #define MaxSize 100
   typedef struct{
       int stack[MaxSize];
       int top1, top2; //两个栈顶指针
   }stk;
   
   stk s;  // s是结构体变量, 为全局变量
   
   // 入栈操作 i为0表示左边的栈,为1表示右边的栈 x为入栈元素
   int push(int i, int x){
       if(i != 0 || i != 1){
           printf("栈号非法!");
           exit(0);
       }
       if(s.top2 - s.top1 == 1){
           printf("共享栈已满!")
           return 0;
       }
       if(i == 0){
           s.stack[++s.top1] = x;
           break;
       }
       else{
           s.stack[--s.top2] = x;
       }
       return 1;
   }
   
   // 出栈操作
   int pop(int i){
       if(i != 0 || i != 1){
           printf("栈号非法!");
           exit(0);
       }
       if(i == 0){
           if(s.top1 == 0){
               print("左边栈空! 出栈失败!")
               return -1;
           }
           return s.stack[s.top1--];
       }
       else{
           if(s.top2 == 0){
               print("右边栈空! 出栈失败!")
               return -1;
           }
           return s.stack[s.top2++];
       }
   }
   ```

   



<br>

---



## 3.2 队列

队列（Queue）简称队，也是一种操作受限的线性表，只允许 **在队尾进行插入** ， **在队头进行删除** 

队的操作特性是 **先进先出（FIFO）** 



### 3.2.2 顺序队列

分配一块连续的存储单元存放队列中的元素。

-  **队头指针front** 指向队头元素
-  **队尾指针rear** 指向队尾元素的下一位置

 **注** ：front和rear的定义要结合题干

```c++
#define MaxSize 50
typedef struct{
	ElemType data[MaxSize];	// 存放元素
	int front, rear;	// 队头和队尾指针
}SqQueue;	// 顺序队列
```

- 初始状态（队空）： `Q.front == Q.rear == 0`
- 进队：当队不满时，先对队尾元素赋值，rear再+1
- 出队：当队不空时，先取出队头元素，front再+1

会有front追上rear的情况，这种是 **假溢出** 





#### 循环队列

将存储队列的表从逻辑上视为一个环，能避免假溢出的缺点。

- 初始时： `Q.front = Q.rear = 0`
- 入队： front不变，rear往后1位 `Q.rear = (Q.rear + 1) % MaxSize `
- 出队： rear不变，front往后1位 `Q.front = (Q.front + 1) % MaxSize`

为了区分是队空还是队满：

1）牺牲一个单元俩区分队空还是队满，以 **front在rear的下一个位置作为队满的标志** 

- 队满：`(Q.rear + 1) % MaxSize == Q.front`
- 队空：`Q.front == Q.rear` 
- 队列中的元素个数：`（Q.rear-Q.front+MaxSize）% MaxSize`

2）结构中设置表示元素个数的数据成员

3）结构中设置tag数据成员，0表示因为出队导致，1表示因为入队导致





### 3.2.3 链队列

实际上是一个带队头指针和队尾指针的单链表，头指针指向队头结点，尾指针指向队尾结点。往往带有 **头结点** 

特点：

- 适和数据元素变动较大的情形
- 不会队满溢出





### 3.2.4 双端队列

两端都可以出队入队，或者是有特殊规定的 **受限的双端队列** 





### 习题

 **选择题** 

1. 用链队列进行出队时需要修改： **头尾指针都可能需要修改 **

   通常出队只需要修改头指针。但当队中只有一个元素时，尾指针也需要进行修改： `rear = front`

2. 【2011】 已知循环队列存储在一位数组A[0…n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列为空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是： **0** ， **n-1** 

   **解答** ：第一个元素入队后在A[0]，此时front和rear都是0。入队时因为要执行 `(rear + 1) % n` 操作，可知rear的初值为n-1。而入队不改变front，所以front的初值为0

3. 【2014】循环队列存放在一维数组A[0…M-1]中，end1指向队头，end2指向队尾元素的后一个位置。假设队列两端都可以进行出入队。队列中最多能容纳M-1个元素，初始为空。则队空和队满的条件是：

   队空：end1 == end2				队满：end1 == (end2 + 1) mod M

   **解释** ：

**应用题**

1. 【2019】请设计一个队列，要求满足：1）初始时队列为空  2）入队时，允许增加队列占用空间 3）出队后，出队元素所占空间可以重复使用 4）出队和入队都在O(1)，问：

   1. 该队列选择链式还是顺序？

      答：链式，为了能增加队列占有空间

   2. 画出队列的初始状态，并给出判断队空和队满的条件

   3. 画出第一个元素入队之后的队列状态

   4. 给出入队操作和出队操作的基本过程



<br>

---



## 3.3 栈和队列的应用

**总结** ：

- 栈：递归、进制转换、迷宫求解
- 队列：缓冲区、页面替换算法、BFS



### 3.3.1 栈-括号匹配

判断输入的括号序列合不合法

```c++
bool judge(){
    
    bool flag = true;
    for(int i = 0; i < str.size(); i ++ ){
        char op = str[i];
        
        // 当前是左括号就入栈
        if(op == '<' || op == '(' || op == '{' || op == '[') stk.push(op);
        else{
            if(stk.empty()){
                flag = false;
                break;
            } 
            if(op == '>' && stk.top() == '<') stk.pop();
            else if(op == ')' && stk.top() == '(') stk.pop();
            else if(op == '}' && stk.top() == '{') stk.pop();
            else if(op == ']' && stk.top() == '[') stk.pop();
            else{
                flag = false;
                break;
            }
        }
    }
    // 最后栈不为空，也非法
    if(!stk.empty()) flag = false;
    
    return flag;
}
```



<br>

### 3.3.2 栈-表达式求值

例如后缀表达式求值



<br>

### 3.3.3 栈-递归

例如递归求斐波那契额数列



<br>

### 3.3.4 队列-求层次遍历

例如求树的层次遍历



<br>

### 3.3.5 队列-计算机系统

关键词： **缓冲区** 

- 解决主机和外设之间速度不匹配的问题：设置打印数据缓冲区
- 解决多用户资源竞争的问题：设置请求队列

<br>

### 习题

 **选择题** 

1. 【2012】已知操作符包括 `+` 、 `-`  、 `*` 、 `/` 、 `(和)` 。将中缀表达式 `a+b-a*((c+d)/(e-f)+g)` 转化为后缀表达式 `ab+acd+e/f-*-g+` 时，用栈来存放暂时不能确定运算次序的操作符。初始栈为空，转换过程中同事保存在栈中的最大操作符个数是： **5** 
2. 【2014】假设栈为空，将中缀表达式 `a/b+(c*d-e*f)/g` 转换为等价的后缀表达式的过程中，当扫描到f时，栈中的元素依次是： **+(-*** 



<br>



## 3.4 数组和特殊矩阵

多维数组：按行优先、按列优先

<br>



### 3.4.3 特殊矩阵的压缩存储

压缩存储：对多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。

- 对称矩阵：只存储上半或下半（包括对角线），按行或按列优先
- 三角矩阵：按行或按列优先
- 三对角矩阵：按行或按列优先

<br>



### 3.4.4 稀疏矩阵

适合于压缩存储稀疏矩阵：

- 三元组表：(行，列，值)
- 十字链表

<br>



### 习题

 **选择题** 

1. 若将n阶上三角矩阵A按列优先压缩存储在一维数组B[1…n(n+1)/2+1]中，则存放到B[k]中的非零元素 $$a_{ij}$$ 的下标i、j和k的关系是： **j(j-1)/2+i** 
2. 若将n阶下三角矩阵A按列优先压缩存储在一维数组B[1…n(n+1)/2+1]中，则存放到B[k]中的非零元素 $$a_{ij}$$ 的下标i、j和k的关系是： **(j-1)(2n-j+2)/2+i-j+1** 
3. 【2016】有一个100阶的三对角矩阵M，其元素 $$m_{ij}$$ （1<= i，j<=100）按行优先压缩存入下标从0开始的一维数组N中。则 $$m_{30,30}$$ 在N中的下标是： **87** 
4. 【2018】设有一个12x12的堆成矩阵M，将其上三角部分元素 $$m_{ij}$$ （1<= i，j<=10）按行优先存入一维数组N中，元素 $$m_{6,6}$$ 在N中的下标是： **50** 
5. 【2020】将一个10x10对称矩阵M的上三角不分的元素 $$m_{ij}$$ （1<= i，j<=10）按列优先存入一维数组N中，元素 $$m_{7,2}$$ 在N中的下标是： **22** 
6. 【2021】二维数组A按行优先存储，每个元素占1个存储单元。若元素 `A[0][0]` 的存储地址是100， `A[3][3]`  的存储地址是220，则元素 `A[5][5]` 的存储地址是： **300**  



<br>

# 第五章：树与二叉树

### 重点

- 各种树的性质（选择题）
- 树的各种遍历（算法题）
- 哈夫曼树哈弗曼编码、并查集



<br>



### 5.1 树

树是一种逻辑结构，树的定义是递归的，适合表示有层次结构的数据

补充：

-  **路径** ：两个结点之间的路径由这两个结点之间的经过的 **结点序列** 组成，树中的路径是 **从上向下** 的
-  **路径长度** ： 路径长经过的 **边** 的个数
-  **树的路径长度** ：从树根到每个结点的路径长度的 **总和** 



<br>



#### 5.1.3 树的性质

1.  **树中结点数**  =  **所有结点度数和**  + 1



<br>

### 5.2 二叉树

二叉树每个结点至多只有两颗子树，且子树有左右之分，是有序树。

**二叉树和度为2的有序树的区别** ：

1. 度为2的有序树至少有3个结点，二叉树可以是空树
2. 度为2的有序树中某个结点要是只有一个孩子，就无左右次序。但二叉树还是有结点次序。



**满二叉树** ： 高度为h，且有2^h^-1个结点的二叉树

**完全二叉树** ： 每个结点都和对应的满二叉树结点一一对应的二叉树。就是对应相同高度的满二叉树缺失右下角的一些连续叶结点

**二叉排序树（BST）** ：左子树的所有结点关键字都小于根结点关键字；右子树上所有结点关键字均大于根结点的关键字；且左右子树均是二叉排序树

**平衡二叉树（AVL）** ： 任一结点左右子树深度差不超过1



**二叉树的性质** ： 

1. 非空二叉树中叶子结点数等于度为2的结点数+1，即 `n0 = n2 + 1`
2. 非空二叉树第k层 **最多** 有2^k-1^个结点
3. 高度为h的二叉树 **最多** 有2^h^-1个结点，此时为满二叉树
4. 有n（n>0）个结点的完全二叉树高度为 log2n下取整再+1



<br>



### 5.3 二叉树的遍历和线索二叉树

**遍历** ： 按某条搜索路径访问树中的每个结点，使得每个结点均被访问一次

常见的遍历：先序(NLR)、中序(LNR)、后续(LRN)



<br>



 **先序遍历(PreOrder)** ：

```c++
// 先序遍历 递归
void PreOrder(BiTree T){
    if(T != NULL){
        visit(T);
        PreOrder(T->lchild);
        PreOrder(T->lchild);
    }
}
```

由于每个结点都恰好被访问一次，因此递归算法的 **时间复杂度** : **O(n)**

在递归过程中，递归工作栈的深度恰好为树的高度，最坏情况下树高为n，因此 **空间复杂度** : **O(n)**



<br>



 **中序遍历(InOrder)** :

递归写法只是访问结点的顺序不同，不再赘述

采用非递归写法需要用到 **栈** 

```c++
//中序遍历 非递归
void InOrder(BiTree T){
    
    //空树
    if (T == NULL) return;
    
    //树非空
    BiTree* p = T;
    stack<BiTree> s;
    while (!s.empty() || p){
        
        //一直遍历到左子树最下边，边遍历边保存根节点到栈中
        while (p){
            s.push(p);
            p = p->lchild;
        }
        
        //当p为空时，说明已经到达左子树最下边，这时需要出栈了
        if (!s.empty()){
            p = s.top();
            s.pop();
            visit(p);
            //进入右子树，开始新的一轮左子树遍历(这是递归的自我实现)
            p = p->rchild;
        }
    }
}
```



<br>



**后序遍历(PostOrder)** ： 

后序遍历的非递归实现起来是最难的。因为要保证左右孩子都已被访问才能访问根结点



**层次遍历**

层次遍历需要一个 **队列** 



<br>



### 5.3.2 线索二叉树

在含有n个结点的二叉树中，有 **n+1** 个空指针

引入线索二叉树的 **目的** ： **为了加快查找结点前驱和后继的速度**

增加两个标志域，并规定：

- 若无左子树，lchild指向其前驱
- 若无右子树，rchild指向其后继
- ltag为0表示左孩子，1表示前驱
- rtag为0表示右孩子，1表示后继

用二叉链表作为二叉树的存储结构，称为 **线索链表** 



<br>



## 5.4 树、森林

树可以用顺序存储，也可以链式存储。

常用的3种存储结构：

1. 双亲表示法
2. 孩子表示法
3. 孩子兄弟表示法



<br>



### 5.4.2 树、森林和二叉树的转换



<br>



### 5.4.3 树、森林的遍历

树的遍历主要有两种方式：

- 先根遍历
- 后根遍历

森林的遍历的两种方式：

- 先序遍历森林
- 后序遍历森林



<br>



## 5.5 树与二叉树的应用

### 5.5.1 哈夫曼树和哈夫曼编码

 **权** ：树中结点带有的的数值

 **结点** 的 **带权路径长度** ：从根到任意结点的路径长度（经过的 **边数** ）与该结点权值得乘积

 **树** 的 **带权路径长度（WPL）** ：所有叶结点的带权路径长度之 **和** 

在含有n个带权叶结点的二叉树中，WPL最小的二叉树称为 **哈夫曼树** （最优二叉树）



**哈夫曼树的构造** ： 



<br>



 **哈夫曼树的性质** ：

- 每个初始结点最后都是叶结点，且结点权值越小，到根结点的路径长度越大
- 构造过程中新建 `n-1` 个结点（双分支结点），结点总数为 `2n - 1`
- 树中不存在度为1的结点



<br>



**哈夫曼编码 ** ： 

从哈夫曼树得到的哈夫曼编码，可以将边标记为

- 0表示转向左孩子
- 1表示转向右孩子

从根结点到叶子结点的路径就是它的哈夫曼编码。

如果有若干个权值不同的结点，那么得到的哈夫曼树不唯一。但是WPL必定相同，且都是最小的



<br>



### 5.5.2 并查集

是一个集合，有3中操作：

- `Initial(S)` 将集合s中每个元素都初始化为只有一个单元素的子集合
- `Union(S, Root1, Root2)` : 把S中的子集合Root2并入Root1，要求互不相交
- `Find(S, x)` : 查找S中x所在自己和的根



**定义** ： 

```c++
#define MaxSize 100
// 集合元素数组（双亲指针数组）
int UFSets[MaxSize];    
```

**初始化** ： 

```c++
void Initial(int S[]){
    for(int i = 0; i < MaxSize; i++ ){
        s[i] = -1;
    }
}
```

**Find** ： 

```c++
int Find(int S[], int x){
    while(S[x] >= 0)
        x = S[x];
    return x;
}
```

**Union** ： 

```c++
void Union(int S[], int Root1, int Root2){
    // 要求Root1和Root2不同
    S[Root2] = Root1;
}
```



<br>



# 第六章 图

### 重点

- DFS、BFS
- 应用：拓扑排序、最小生成树、最短路径、关键路径



<br>



## 6.1 图的基本概念

图G由顶点集V和边集E组成，记为G=(V，E)

V(G)：图G中顶点的有限非空集，|V|表示顶点个数

E(G)：图G中边的有限非空集，|E|表示边的条数



注：线性表、树可以为空，但图不可为空（V非空，E可为空）



基本概念：

- 有向图：有向边也称为弧。 `<v, w>` 称为v到w的弧。其中v是弧尾，w是弧头
- 无向图：边： `(v, w)`
- 完全图：图中任意两个顶点之间都有边。类似的：有向完全图
- 子图：顶点集合边集都是原来图的子集。如果含原来图的全部顶点就是生成子图。注：并非任何子集都能组成子图
- 连通：有路径存在。类似的：强连通
- 连通图：无向图中任意两个顶点都是连通的
- 连通分量：无向图中的极大连通子图
- 强连通图：有向图中任意两个顶点都是强连通的
-  **生成树** ：包含图全部顶点的极小连通子图
- 生成森林：非连通图连通分量的生成树构成
- 度：无向图中一个顶点上边的条数。 入度ID、出度OD
- 权：带权的图也称为网
- 稠密图：边多。稀疏图：边少。
-  **路径** ：由顶点和相邻顶点序偶组成的 **边** 所形成的序列
-  **路径长度** ：路径上 **边的数目** 
- 环/回路：如果n个结点，有大于n-1条边
- 简单路径：顶点不重复出现。简单回路：除了起点和终点重复。
-  **距离** ：如果最短路径存在， **最短路径的长度** 。若不存在路径，则距离为无穷 ∞
- 有向树：顶点入度为0，其余顶点入度为1



<br>



补充：

- 无向图：全部顶点的度数和 = 边数的2倍
- 有向图：全部顶点的出度和 = 入度和 = 边数
- 极大连通子图：要求包含所有的边
- 极小连通子图：要求边数最少，少了一条就会非连通



<br>



### 习题

1. 强连通有向图任何顶点到其他所有顶点都有弧（ **错误** 

    **解释** ：强连通有向图的任何顶点到其他所有顶点都有 **路径** ，但未必有 **弧** 

2. 有向完全图一定是强连通有向图（ **正确** 

3. 一个有28条边的非连通无向图至少有顶点：**9**

    **解释** ：考虑非连通图最极端的情况：由一个完全图和一个独立的顶点组成，此时多一条边就是连通图。`28 = n(n-1)/2` 得到n = 8。再加上一个独立顶点得到9

4. 若一个具有n个顶点、e条边的无向图是一个森林。则森林中必有 **n-e** 棵树

    **解释** ：n个顶点的树有n-1条边。假设有x棵树组成森林，可以通过增加1个结点和x条边使森林组成一棵树。此时树有n+1个结点，e+x条边。列方程`n+1 = e + x + 1` ，解得 `x = n - e` 

5. 【2010】若无向图G=(V,E)中含7个顶点，要保证图G在任何情况下都是连通的，最少需要的边数 **16** 

    **解释** ：首先先让6个结点组成一个完全图，再加上一条边就必定能保证另一个结点也连通。6个结点的完全图需要 `6*(6-1)/2=15` ，再加上一条边得到16

7. 【2017】已知无向图G有16条边 ，其中度为4的顶点个数为3，度为3的顶点个数为4，其他顶点的度均小于3。图G所含顶点个数 **至少** 为 **11**

    **解释** ：至少的话，其余顶点都是度为2的顶点。 **无向图各顶点的度数之和 = 边数的2倍** 。列出方程：`4*3+3*4+2*x = 16*2`，得其他顶点为4。因此总顶点数`4+4+3=11`



<br>



## 6.2 图的存储及基本操作

### 6.2.1 邻接矩阵

用一个一维数组存储顶点，用一个二维数组（矩阵）存储边。存储顶点之间邻接关系的二维数组称为 **邻接矩阵** 

`A[I][J]` :  

- 1是边，0不是边
- 带权图：权Wij表示右边，0或∞表示不是边



<br>



**重点** ： 

- 有向图： **行是出，列是入** 。第i行非0元素（或者非∞元素）的个数为出度OD
- 无向图：一定是 **对称矩阵** ，且唯一。因此可以 **压缩存储** ，只存储一半
- 无向图：第i行或者i列非0元素（或者非∞元素）的个数为顶点i的度TD
-  **优点** ： **容易确定图中任意两个顶点之间是否有边** 
-  **缺点** ： **不容易确定图中有多少条边** 。需要遍历整个邻接矩阵，花费的时间很大
-  **适合** ： **稠密图** （边多）
- 设图G的邻接矩阵A，An的元素Anij等于 **从i到j的长度的长度为n的路径的数目** 



<br>



### 6.2.2 邻接表

对图G中每个顶点建立一个单链表，第i个单链表中 **结点** 表示依附于顶点Vi的 **边** （有向图则是弧），这个单链表就称为顶点Vi的 **边表** (有向图则是 **出边表** )

边表的头指针和顶点的数据信息采用 **顺序存储** （称为顶点表）

邻接表中有 **顶点表结点** 和 **边表结点** 



<br>



### 6.2.3 十字链表

### 6.3.4 邻接多重表



<br>



## 6.3 图的遍历

图的遍历指的是从图的某一顶点触发，按照某种搜索方法沿图中的边 **对图中所有结点访问一次且仅访问一次** 



<br>



### 6.3.1 广度优先搜索BFS

 **类似于二叉树的层序遍历** 。 **Dijkstra单源最短路径算法** 和 **Prim最小生成树算法** 也有类似的思想

BFS是一种分层查找的过程，不像DFS那样有回退的情况。因此它 **不是一个递归的算法** 

为了实现逐层访问，算法需要借助一个 **辅助队列** 



<br>



**BFS的伪代码：**

```c++
bool visited[MaxSize] = {false};  // 访问标记数组, 初始化都为false

void BFSTraverse(Graph G){
    
    初始化辅助队列Q;
    for(遍历v的每个结点)
        // 对每一个连通分量进行BFS
        if(结点i未被访问) 
            // 如果vi未访问, 从vi开始BFS
            BFS(G, i);  // BFS()调用的次数就是连通分量数
}

// 从顶点v开始, BFS遍历G
void BFS(Graph G, int v){
    访问v, 并标记已访问;
    
    v入队;
    
    while(队列非空){
        队头出队, 记作v;
        
        for(遍历所有v的邻接点w){
            if(w未被访问){
                访问w并标记;
                w入队;
            }
        }
    }
}
```



<br>



**1、BFS的复杂度分析：**

无论是邻接表还是邻接矩阵，BFS都需要一个辅助队列Q，n个顶点都需要入队一次， **空间复杂度：O(|v|)** 

采用 **邻接表** ：

- 每个顶点入队一次，时间复杂度O(|v|)
- 每条边都至少被访问一次，时间复杂度O(|E|)
-  **总的时间复杂度为O(|v| + |E|)** 

采用 **邻接矩阵** ：

- 需要遍历整个矩阵， **时间复杂度O(<img src="http://chart.googleapis.com/chart?cht=tx&chl= |v|^{2}" style="border:none;">)** 



<br>



**2、BFS解决单源最短路径问题：**

伪代码：

```c++
void BFS(Graph G, int u){
    // d[i]表示从u到i的距离    
    整个d[]数组初始为无穷;
        
    标记u已访问;
    d[u] = 0;
    u入队;
    while(队列非空){
        u出队;
        for(u的邻接结点w)
            if(未被访问){
                标记w已访问;
                d[w] = d[u] + 1;
                w入队;
            }
    }
}
```



<br>



### 6.3.2 深度优先搜索DFS

类似于树的 **先序遍历** ，策略是尽可能 **深** 地搜索一个图

从图的某一结点v出发，访问与v相邻且未被访问的任意结点w，再从w出发……重复过程。当不能再继续向下访问时，依次退回到最近被访问的结点，若它还有邻接结点未被访问，则从该点开始继续上述搜索过程，直到图中所有结点都被访问为止。



<br>



**递归形式DFS的伪代码：**

```c++
bool visited[MaxSize] = {false};  // 访问标记数组, 初始化都为false

void DFSTraverse(Graph G){
    for(从v0开始的每一个结点)	// 遍历每个连通分量
        if(未被访问)
            DFS(G, v);	// DFS()调用的次数就是连通分量数
}

void DFS(Graph G, int v){
    访问v, 并标记;
    
    for(和v相邻的所有结点w)
        if(w未被访问)
            DFS(G, w);
}
```





<br>



**1、DFS的复杂度分析：**

DFS是一个递归算法，需要用到一个递归工作栈，栈中存放所有结点，因此 **空间复杂度为O(|V|)** 

**时间复杂度花在查找每个结点的邻接点上**

采用 **邻接表** ：

- 访问每个顶点，时间复杂度O(|v|)
- 查找所有顶点的邻接点需要的时间复杂度O(|E|)，也就是边的数目
- **总的时间复杂度为O(|v| + |E|)** 

采用 **邻接矩阵** ：

- 查找每个结点临界点需要用时O(|V|)，总共有O(|V|)个结点。因此 **时间复杂度O(<img src="http://chart.googleapis.com/chart?cht=tx&chl= |v|^{2}" style="border:none;">)** 



<br>



### 广度、深度优先生成树

**注意** ：

- 邻接矩阵唯一，所以广度优先生成树唯一
- 邻接表不唯一，所以广度优先生成树不唯一
- 对连通图能生成树，否则就是生成森林



<br>



### 习题

**选择题：**

1. 图的广度优先生成树的树高比深度优先生成树的树高 **小或相等**

   **解释** ： 对于广度优先生成树，顶点到其他顶点的路径是图中对应的最短路径。树高最小。深度有点生成树因为是深，路径尽可能长，所以树比较高



**应用题：**

1. 写出图的DFS算法的非递归算法（图采用邻接表形式）

2. 设计一个算法， **判断一个无向图G是否是一棵树** ，是返回true，否返回false

   思路：判断G是树的条件是，G必须是 **无回路的连通图** ，或者是 **有n-1条边的连通图** ，采用后者

   因此，采用DFS，并在遍历过程中记录访问到的顶点个数和边的条数， **如果一次DFS就能访问到n个顶点、n-1条边，则说明是树** 

   

   ```c++
   bool isTree(Graph G){
       // 初始化访问数组
       for(int i = 1; i < G.vexnum; i++ )
           visited[i] = false;
       
       // 顶点数、边数初始化为0
       int Vnum = 0, Enum = 0;
       
       DFS(G, 1, Vnum, Enum, visited);
       
       // 判断是否满足是树的条件 一条边会被记录两次
       if(Vnum == G.vexnum && Enum == 2 * (G.vexnum - 1))
           return true;
       return false;
       
   }
   
   // DFS 记录遍历过程中的顶点数和边数
   void DFS(Graph& G, int v, int& Vnum, int& Enum, int visited[]){
       visited[v] = true;
       Vnum++;
       
       // w取v的第一个邻接点
       int w = FirstNeighbor(G, v);
       while(w != -1){
           // 有邻接点 边数+1
           Enum++;
           if(!visited[w])
               DFS(G, w, Vnum, Enum, visited);
           // w取下一个邻接点
           w = NextNeighbor(G, v, w);
       }
   }
   ```

   

<br>



## 6.4 图的应用

是重点，包括：最小生成树、最短路径、拓扑排序、关键路径



<br>



### 6.4.1 最小生成树

一个连通图的 **生成树** 包含图的全部顶点，和尽可能少的边。

- 如果少一条边，就会非连通
- 如果多一条边，就会有回路

对于一个 **带权连通图** 来说， **最小生成树（MST）** 是它的 **所有生成树中权值之和最小** 的那棵生成树

**最小生成树的性质：**

1. 树形不唯一，但若图G中各边权值互不相等，则最小生成树唯一。当G本身是一棵树（边数  = 顶点数 - 1），最小生成树是它本身
2. 最小生成树的权值和总是唯一的

通用的最小生成树算法：

```c++
get_MST(Graph G){
    T = NULL;
    while T未形成一棵树:
        do 找到一条 最小权值 且 加入不会产生回路 的边;
            加入T;
}
```



<br>



#### Prim算法

类似于 **最短路径的Dijkstra算法** 

Prim算法的思想：

1. 初始时任选一顶点加入树T
2. 每次选择一个 **与当前树T中顶点集合距离最近的顶点** ，将对应顶点和边加入T
3. 直到图G所有顶点都加入T

Prim伪代码：

```c++
void Prim(G, T){
    // T顶点集合 E边集合
    T = {};     // 初始化空树
    E = {w};    // 任意加入一个顶点w
    while(T中不含G的全部丁点)：
        找到权值最小的边(w, u)
        顶点、边加入对应集合
}
```



Prim复杂度分析：

-  **时间复杂度O(<img src="http://chart.googleapis.com/chart?cht=tx&chl= |v|^{2}" style="border:none;">)** ，和|E|无关，因此 **适合稠密图** ，（ **Prim选的是顶点，边多无所谓！** ）



<br>



#### Kruskal算法

 **Prim选择的是顶点，Kruskal选择的是边** ， **按边的权值递增次序** 选择合适的边来构造最小生成树

```c++
void Kruskal(v, T){
    T = {v};    // 初始化树T, 仅含顶点v 
    Snum = n;   // Snum连通分量数, 初始等于顶点数n
    
    while(Snum > 1){
        从E中取出权值最小的边(v, u);
        if(v 和 u属于不同的连通分量){
            边(v, u)加入生成树
            Snum--; // 连通分量数-1
        }
    }
}
```

通常在Kruskal算法中，采用 **堆** 来存放边的集合，因此每次选取最小权值的边只需O(log|E|)的时间。

用 **并查集** 来描述T，从而构建T的 **时间复杂度为O(|E|log|E|)** ，只和边有关，因此 **适合稀疏图**  ，( **Kruskal选择边，适合边少的图** )



<br>



### 6.4.2 最短路径

 **无权图** 找最短路径： **BFS** 

 **带权图** ：从一个顶点v0出发到图的某一顶点的路径（可能不只一条）经过的边的权值之和，定义为 **该路径的带权路径长度** 

带权路径长度最短的那条路径称为 **最短路径** 

求解最短路径的算法通常以来与一种 **性质** ： **两点之间的最短路径也包含了路径上其他中间顶点间的最短路径**

最短路径问题分为两类：

-  **单源最短路径问题** ：（即求某点到其他各顶点的最短路径） **Dijkstra算法**
-  **求每对顶点间的最短路径** ： **Floyd算法** 



<br>



#### Dijkstra算法

设置一个 **集合S** 记录已求得的最短路径的顶点。

初始时，源点v0放入S，S中每新加入一个结点就需要修改源点v0到集合中其他顶点的最短距离长度值。 **看看通过绕道能否是距离变得更短**

构造的时候设置了两个辅助数组：

-  **dist[ ]** ：  记录源点到其他各个顶点的 **当前的** 最短路径长度。初始化为dist[0] = 0，其他设置为无穷
-  **path[ ]** :  path[i] 表示从源点到顶点vi的最短路径的 **前驱结点**  ，算法结束时，可以追溯到源点v0到顶点vi的距离

用 **邻接矩阵arcs** 存储 **带权有向图** 

Dijkstra算法是 **基于贪心** 策略的



<br>



**Dijkstra算法的步骤：**

1. 初始化： S初始化为{0}，dist[ ] 初始化 `dist[0] = arcs[0][i]` ，就是从0出发 **直接** 到达其他顶点的距离
2. 从顶点集合中选出vj， **满足dist[j] 是当前dist中最小的那个** ，vj就是当前求得的从v0出发的最短路的终点， **将vj归入集合S** 
3. 根据vj，对其他dist[ ]进行更新： **如果绕道vj，能使得距离变小，就更新为小的距离** 

循环一次可以确定一个点的最短距离，循环n-1次完成，最终所有的顶点都在S中



<br>



**手动模拟Dijkstra：**



<br>









**注意：**

- 当边带有 **负权值** 时，Dijkstra算法并不使用

-  **只用考虑有向图的算法** ， 因为无向图可以看做是特殊的有向图，即两个方向都有弧



<br>



**Dijkstra复杂度分析：**

- 使用 **邻接矩阵** 存储时，时间复杂度为O(<img src="http://chart.googleapis.com/chart?cht=tx&chl= |v|^{2}" style="border:none;">)

- 使用 **带权的邻接表** 存储时，虽然修改dist[ ]的时间会减少，但在dist[ ]中找到最小分量的时间不变，时间复杂度还是时间复杂度为O(<img src="http://chart.googleapis.com/chart?cht=tx&chl= |v|^{2}" style="border:none;">)



---

<br>



#### Floyd算法

问题描述：已知一个各边权值均大于0的带权有向图，对任意两个顶点Vi != Vj，要求求出Vi和Vj之间的最短路径和路径长度



**Floyd算法的基本思想：**

Floyd的思想是基于 **动态规划DP** 的

首先对于邻接矩阵A，如果 `<i, j>` 存在，则 `A[i][j] = 边的权值` ，否则就是无穷。

随后对邻接矩阵递推n次， **递推到k次时，判断两个点之间的最短路能否通过绕行第k个点实现变小，如果可以就用新路径来代替原路径** 

```c++
// k代表递推的次数 可以省略
A[k, i, j] = min(A[k, i, j] , A[k-1, i, k] + A[k-1, k, j])
```

A[k, i, j] 可以认为是顶点i和顶点j在中间顶点是0~k情况下的最短路。n次迭代后，最后邻接矩阵中的结果就是所求的答案。



<br>



**Floyd算法的手动模拟：**

![Floyd](assets/数据结构笔记/Floyd.png)



<br>



**Floyd算法的复杂度分析：**

时间复杂度为O(<img src="http://chart.googleapis.com/chart?cht=tx&chl= |v|^{2}" style="border:none;">)

Floyd算法 **允许带有负权值的边** ，但 **不能有负权值的边组成的回路** 

可以用于无向图（试做两边都有弧的特殊的有向图）



<br>



### 6.4.4 拓扑排序

有向无环图，也叫 **DAG图** ，是描述含有公共子式的表达式的有效工具

**AOV网** ： 若用DAG图表示一个工程，**顶点表示活动**， 用 **有向边** `<i, j>` 表示活动i必须先于活动j的 **先后次序** ，这种有向图称为用顶点表示活动的网络称为AOV网

 **拓扑排序** ：由一个有向无环图的顶点组成的序列，且满足：

1. 每个顶点出现且只出现一次
2. 若A在拓扑排序中在B之前，则图中不存在B到A的路径
3. 每个AOV网都有一个或者多个拓扑排序序列

**拓扑排序的用处：**

- 拓扑排序可以判断一个图中是否有环
- 可以确定顶点的前驱后继关系



<br>



 **对一个AOV网进行拓扑排序的算法步骤（重点）：**

1. 从AOV网中选择一个 **没有前序（入度为0）** 的顶点并输出
2. 从网络中 **删除该顶点和所有以它为起点的有向边** 
3. 重复1和2直到AOV网为空或者网中不存在无前驱的结点。后者说明有向图中必然有环。



<br>



**手动模拟求拓扑排序：**



<br>



**拓扑排序的代码：**

```c++
// 拓扑排序
bool TopologicalSort(Graph G){
    InitStack(S);   // 初始化栈S，用于存储入度为0的顶点
    for(int i = 0; i < G.vexnum; i++ )
        if(indegree[i] == 0)    // 入度为0就入栈
            Push(S, i);
            
    int count = 0;  // 记录已经输出的顶点个数
    while(!IsEmpty(S)){ // 只要栈非空
        Pop(S, i); // 栈顶出栈
        res[count++] = i;
        // 将i指向的结点的入度减1, 并且将入度减到0的顶点入栈
        for(p = G.vertices[i].firstarc; p; p = p->nextarc){
            v = p->adjvex;
            if((--indegree[v]) == 0)
                Push(S, v);
        }
    }
    
    // 拓扑排序中结点个数小于顶点数, 说明有环
    if(count < G.vexnum)
        return false;
    return true;
    
}
```

复杂度分析：

输出顶点的同时还需要删除以该顶点为起点的边，因此

- 采用 **邻接表** 存储时，求拓扑排序的 **时间复杂度为O(|V|+|E|)** 
- 采用邻接矩阵存储时，求拓扑排序的 **时间复杂度O(<img src="http://chart.googleapis.com/chart?cht=tx&chl= |v|^{2}" style="border:none;">)** 



<br>



**采用DFS来求拓扑排序：**

**思路：**

对于有向无环图中的两个结点u、v有三种关系：

- u是v的祖先：在调用DFS的过程中，v的DFS函数结束时间一定在u的DFS结束时间之前。可以添加一个 **时间标记** ，**子孙的结束时间一定早于祖先的结束时间**
- v是u的祖先：同理，反过来
- u和v没有关系：在拓扑序列中任意

因此可以按照结束时间从大到小（ `祖先->子孙` ）的顺序，得到拓扑排序序列。 **DFS算法和原版相比就多了个求 结点结束时间** 

```c++
bool visited[MAX_VERTEX_NUM]; // 标记访问数组
int time = 0;

// 对图G进行遍历, 访问函数为visit()
void DFSTraverse(Graph G){
    初始化访问数组为False;
    
    for(v = 0; v < G.vexnum; ++v )
        if(!visited[v]) DFS(G, v);
}

void DFS(Graph G, int v){
    visited[v] = True;
    visit(v);
    
    // 遍历v的所有未被访问的邻接结点u
    for(u = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, u)){
        if(!visited[u])
            DFS(G, u);
    }
    time = time + 1;
    Time[v] = time;
}
```

最后 **按照结束时间从大到小** 就可以得到拓扑排序序列

可以用map记录（时间， 下标），然后按时间排序，输出下标



<br>



**逆拓扑排序：**

 **对一个AOV网进行逆拓扑排序的算法步骤：**

1. 从AOV网中选择一个 **没有后继（出度为0）** 的顶点并输出
2. 从网络中 **删除该顶点和所有以它为终点的有向边** 
3. 重复1和2直到AOV网为空或者网中不存在无后继的结点。后者说明有向图中必然有环。



<br>



**拓扑排序的补充：**

1.  **入度为0的顶点** ，是没有前驱活动或者前驱活动已经完成的顶点， **工程可以从这个顶点代表的活动开始或者继续** 
2. 若一个顶点有多个直接后继，拓扑排序结果通常不唯一
3. 若每一个顶点都有唯一的前驱和后继关系，则拓扑排序结果唯一
4. 对于一般的图来说， **若邻接矩阵是三角矩阵，则存在拓扑排序** ，反之不一定成立



<br>



### 6.4.5 关键路径

在带权有向图中，用 **边表示活动的网络** ，称为 **AOE网** 

-  **顶点** 表示 **事件** 
-  **有向边** 表示 **活动** 
- 边上的 **权值** 表示完成该 **活动的开销** 



**AOE网和AOV网的区别：**

- AOE网的边有权值，表示活动的开销
- AOV网的边无权值，只表示活动的先后次序



<br>



**AOE网的性质：**

- 只有某顶点代表的 **事件发生后** ， **从该顶点出发的弧代表的活动才能开始** 
- 只有以某顶点为终点的所有边代表的 **活动完成后** ， 该顶点代表的时间才能发生
- 只有一个源点（入度为0）和一个汇点（出度为0），汇点代表整个工程的结束



<br>



只有当一条从源点到汇点的路径上的活动都完成，整个工程才会结束。

因此，将所有从源点到汇点的路径中 **具有最大路径长度的路径** 称为 **关键路径** ，关键路径上的活动被称为 **关键活动** 。

关键活动影响了整个工程的时间，缩短关键活动（如果关键路径有很多条，那就取交集）可以缩短工程的完成时间。



<br>



**找到关键活动的几个参量：**

1、**事件Vk** 的 **最早发生时间ve(k)**  : 

**记忆：v指的顶点， e指的early**

指的是从源点V1到顶点Vk的最长路径长度， **事件Vk** 的最早发生时间决定了所有从Vk开始的活动的最早开始时间

```c++
// 递推公式
ve(源点) = 0
ve(k) = Max{ve(k的任意前驱j) + Weight(j, k)}
```



计算ve()时， **从源点开始从前往后** 的顺序计算，可以在 **拓扑排序** 的基础上计算

```c++
1. 开始时, 令ve[1…n] = 0
2. 在拓扑排序过程中, 输出一个入度为0的顶点Vj时, 计算它所有直接后继顶点Vk的ve值。以此类推直到输出所有顶点
   if(ve[k] < ve[i] + Weight(j, k)) ve[k] = ve[i] + Weight(j, k);
```



<br>



2、**事件Vk** 的 **最迟发生时间vl(k)**  : 

**记忆：v指的顶点， l指的late**

指的是在不推迟整个工程完成的前提下，能够保证他的后继事件Vl在它的最迟发生事件vl(l)能够发生的最迟发生时间

```c++
// 递推公式
vl(汇点) = ve(汇点)
vl(k) = Min{vl(k的任意后继l) - Weight(k, l)}
```



计算vl()时， **从汇点开始从后往前** 的顺序计算，可以在 **逆拓扑排序** 的基础上计算

```c++
1. 开始时, 令vl[1…n] = ve[n]
2. 用一个栈来记录拓扑排序，拓扑排序结束后从栈顶到栈底就是逆拓扑排序
   栈顶顶点Vl出栈, 计算它所有直接前驱顶点Vk的vl值。以此类推直到输出所有顶点
   if(vl[k] > vl[l] - Weight(k, l)) vl[k] = vl[l] - Weight(k, l);
```



<br>



3、 **活动ai** 的 **最早开始时间e(i)** :

指的是 **有向边(它代表活动)**  的 **起点** 所代表的的 **事件的最早开始时间** 。

如果 `<k, l>` 表示活动ai，则有`e(i) = ve(k)`



<br>



4、 **活动ai** 的 **最迟开始时间l(i)** :

指的是 **有向边(它代表活动)**  的 **终点** 所代表的的 **事件的最迟开始时间** 和 **该活动所需时间** 之差。

如果 `<k, l>` 表示活动ai，则有`l(i) = vl(l) - Weight(k, l)`



<br>



5、 **活动ai** 的 **最迟开始时间l(i)** 和 **最早开始时间e(i)** 的 **差值 d(i) = l(i) - e(i)** :

指的是该活动完成的 **时间余量** ，即在不增加整个工程的总时间下， **活动ai可以拖延的时间** 

如果一个活动的时间余量为0，说明该活动必须如期完成，否则就会拖延整个工程的进度。

称 `l(i) = e(i)` 的活动为 **关键活动** 



<br>



**求关键路径的步骤：**

1.  **从源点出发** ，令 **ve(源点) = 0** ， 按 **拓扑排序** 求所有顶点的 **最早发生时间ve()** 
2.  **从汇点出发** ，令 **vl(汇点) = ve(汇点)** ， 按 **逆拓扑排序** 求所有顶点的 **最迟发生时间vl()** 
3. 根据各 **顶点的最早发生时间ve()** 求出所有 **弧的最早开始时间e()** 
4. 根据各 **顶点的最迟发生时间vl()** 求出所有 **弧的最迟开始时间l()** 
5. 求出AOE网中所有活动的 **时间余量d()** ，找出所有 `d() = 0` 的活动组成关键路径



<br>



**手动模拟求关键路径：**



<br>



### 习题

**选择题：**

1. 可以 **判断一个有向图是否有环** 的方法有： **DFS** 、 **拓扑排序** 、 **求关键路径** 
2. 在拓扑排序算法中暂存入度为0的顶点可以用栈，也可以用队列（ **正确** 
3. 在图G的最小生成树T中，某条边的权值可能会超过未选边的权值（ **正确** 
4. 若有向无环图的拓扑序列唯一，则可以唯一确定该图（ **错误** 
5. 一个事件的最迟发生时间是以该事件为尾的弧的活动的最迟开始时间与该活动的持续时间的差（ **错误** 

<br>



**应用题：**

1. 下面是一种被称为 **破圈法** 的求解最小成生成树的方法：

   "任取一圈去掉圈上权值最大的边"， 重复执行，直到没有圈为止。

   判断是否正确，并给出理由

   答： **正确** 

   因为破圈法最终一定没有环，因此它 **一定能够形成一个生成树** 。下面证明它 **最小** ：

   **王道用的反证法，感觉写的并不是很清楚，以后再补充吧- =**

   

2. 已知有向图：

   1）写出该图的邻接矩阵表示并据此给出从顶点1出发的深度优先遍历序列

   2）求该有向图的强连通分量的数目

   3）给出该图的任意两个拓扑序列

   4）若将该图视为无向图，分别用Prim算法和Kruskal算法求最小生成树



<br>



## 第七章 查找

### 重点

- 散列查找：构造、冲突处理办法、成功和失败的平均查找长度、特征、性能分析
- 二分查找：过程、判定树、平均查找长度
- B树：插入、删除、查找
- B+树：概念、性质，B树和B+树的比较



<br>



 **平均查找长度（ASL）：** 是所有查找过程中 **关键字比较次数的平均值** 



<br>



### 7.2.1 顺序查找

也称为线性查找，实用于 **顺序表** 和 **链表** ，通常分为

- 一般的线性表的顺序查找
- 按关键字有序的线性表的顺序查找



<br>



**1、一般的线性表的顺序查找**

从一端开始，逐个进行关键字比较

```c++
int search(Table t, int key){
    t.elem[0] = key;    // 哨兵
    for(int i = t.len; t.elem[i] != key; --i )
        return i;   // 当i到0时会自动退出循环
}
```

 **引入哨兵的作用** ：减少判断是否越界的判断语句

对于n个元素的表：

- 查找成功时：当每个元素查找概率都相等也就是1/n时，此时 `ASL = (n+1)/2` 
- 查找失败时：比较次数n+1次，此时 `ASL = n+1` 

性能分析：

- 缺点：n较大时，ASL较大，效率低
- 优点：对存储没有要求



<br>



**2、有序表的顺序查找**

可以降低查找失败的ASL

可以用一个 **判定树** 来描述有序表的查找过程

- 查找成功：查找长度为它（圆形结点）的层数
- 查找失败：查找长度为它（矩形结点，实际不存在）的父节点的层数



<br>



### 7.2.2 折半查找

也称 **二分查找** ， **仅适用于有序的顺序表** 

 **基本思想：** 

将给定key值与表中间位置的元素比较，相等则查找成功，失败则查找中间元素 **以外** 的前半或后半部分，重复直到查找成功或者失败为止。

```c++
// 二分查找
int Binary_Search(SeqList l, int key){
    int low = 0, high = l.size() - 1, mid;
    while(low <= high){
        mid = (low + high) / 2;
        
        // 查找成功
        if(l.elem[mid] == key)
            return mid;
        else if(l.elem[mid] > key)
            high = mid - 1;
        else
            low = mid + 1;
    }
    // 查找失败
    return -1;
}
```

二分查找的时间复杂度：O(logn)，就是判定树的树高



<br>



**手动模拟求给定判定树的成功和失败的ASL：**



<br>



### 7.2.3 分块查找

也称 **索引顺序查找** ，既有动态结构，也适于快速查找

 **基本思想：** 

将查找表分为若干 **子块** ：块内可以无序，但块间有序。（即第二个块中最小的都比第一个块中最大的大）

再建立一个索引表：索引表中的元素包括每块的最大关键字和每块的第一个元素的地址。索引表按照关键字有序排列

 **分块查找的过程：** 

1. 在索引表中确定待查记录所在的块（顺序或折半）
2. 块内顺序查找



<br>



**重点：**

- 长度为n的查找表，当每块中含有 **根号n** 个记录时，有ASL取到最小值 **根号n + 1**



<br>



### 习题

**选择题：**

1. 对于长度为n的有序单链表进行查找，查找表中任一元素的成功的ASL为： **(n+1) / 2** 

2. 对于表长为n的有序表进行折半查找，判定树的高度为： **log(n+1)向上取整** 

3. 具有12个关键字的有序表中，对每个关键字的查找概率相同，折半查找算法查找成功的ASL为 **37/12** ，折半查找失败的ASL为 **49/13** 

   解释：

4. 为提高查找效率，对有65025个元素的有序顺序表简历索引顺序结构，在最好情况下查找到表中已有元素 **最多** 需要执行 **16** 次关键字比较

   解释：

5. 【2017】下列二叉树中，可能成为折半查找判定树（不含外部结点）的是： **A** 

   ![第七章_解答题_选择题5](assets/数据结构笔记/第七章_解答题_选择题5.png)
   
   解释：
   
   符合折半查找的判定树实际上是二叉排序树，重点在于 **求mid = (low + high) / 2 的时候是向上取整还是向下取整，整棵树应该保持一致**



<br>



**应用题：**

1. 有序顺序表中元素依次为017、094、154、170、275、503、509、512、553、612、677、765、897、908

   1）画出其对应的折半查找的判定树

   2）若查找275或者684的元素，将依次与表中的哪些元素进行比较？

   3）分别计算查找成功和失败的ASL

   解：

   ![第七章_习题_解答题1](assets/数据结构笔记/第七章_习题_解答题1.PNG)

   

2. 写出折半查找的递归算法。初始调用时，`low = i,  high = ST.length` 

   ```c++
   /*
   基本思想: 根据查找的起始和终止位置, 将序列一分为二
   然后对新的起始和终止位置递归求解
   
   时间复杂度:O(logn)
   空间复杂度:O(logn), 递归调用栈的深度
   */
   
   // 查找表
   typedef struct{
       int* elem;  // 存储空间基质
       int length; // 表长
   }SSTable;
   
   // 二分查找的递归实现
   int BinSearch(SSTable st, int key, int low, int high){
       if(low > high)
           return 0;
       
       int mid = (low + high) / 2;
       if(key > st.elem[mid])
           return BinSearch(st, key, mid + 1, high);
       else if(key < st.elem[mid])
           return BinSearch(st, key, low, mid - 1);
       else
           return mid;
   }
   
   
   ```

3. 线性表中各结点的检索概率不等时，可用如下策略提高顺序检索的效率：若找到指定的结点，则将该结点和其前驱（若存在）交换，使得经常被检索的结点尽量位于表的前端。试设计在顺序结构和链式结构的线性表上实现上述策略的顺序检索算法。

   ```c++
   // 顺序查找线性表, 找到后和其前面的元素互换
   int SeqSearch(int a[], int k){
       int i = 0;
       while((a[i] != k) && (i < n))
           i++;
       
       // 如果有前驱结点, 交换    
       if(i < n && i > 0){
           swap(a[i], a[i - 1]);
           // 返回交换后的下标
           return --i;
       }
       else 
           return -1;
   }
   
   // 链式存储区别主要就在 交换 那一步
   ```

   

3. 【2013】设包含4个数据元素的集合S = {'do', 'for', 'repeat', 'while'}，各元素的查找概率依次为p1 = 0.35， p2 = 0.15， p3 = 0.15， p4 = 0.35。将S保存在一个长度为4的顺序表中，采用折半查找法，查找成功的ASL = 2.2

   1）若采用顺序结构保存S，且要求ASL更短，则元素应该如何排列？应使用何种查找方法？查找成功的ASL？

   2）若采用链式结构……

    **解：** 
   
   1）采用顺序查找时，元素按其查找概率降序排列时，查找长度最小
   
   此时 `ASL成功 = 0.35 * 1 + 0.35 * 2 + 0.15 * 3 + 0.15 * 4 = 2.1`
   
   2）链式结构，只能采用顺序查找，性能和上面一样， `ASL成功 = 2.1` 
   
   还可以用二叉链表组成二叉排序树，（类似以哈夫曼树的感觉）， `ASL成功 = 2.0`



<br>



## 7.3 树型查找

### 7.3.1 二叉排序树（BST）

 **定义** ：或者是一棵空树，或者是具有以下特性的二叉树：

- 左 < 根 < 右
- 左右子树也分别是一棵二叉排序树



<br>



 **BST的查找：** 

从根结点开始，沿某个分支逐层往下的过程。是一个 **递归** 的过程：

```c++
// 二叉排序树的非递归查找算法
BSTnode* BST_Search(BiTree t, int key){
    while(t != NULL && key != t->data){
        if(key < t->data)   t = t->lchild;
        else t = t->rchild;
    }
    return t;
}
```



<br>



 **BST的插入：** 

1. 若原BST为空，则直接插入结点
2. 否则，当关键字小于根结点，则插入左子树，当关键字大于根结点，则插入右子树

插入的结点一定是个 **叶节点** 

```c++
// 二叉排序树的插入
int BST_Insert(Bitree &t, int k){
    // 原树为空, 新插入的结点作为根结点
    if(t == NULL){
        t = (Bitree)malloc(sizeof(BSTNode));
        t->data = k;
        t->lchild = t->rchild = NULL;
        return 1;
    }
    // 有相同结点, 插入失败
    else if(k == t->data)
        return -1;
    
    else if(k < t->data)
        return BST_Insert(t->lchild, k);
    else if(k > t->data)
        return BST_Insert(t->rchild, k);
}
```

二叉排序树的 **构造** 就是一个 **依次将结点插入的过程** 



<br>



 **BST的删除：** 

分类讨论：

1. 如果删除结点z是 **叶节点** ： **直接删除** 
2. 如果结点z只有一棵左子树或者右子树， 则让 **z的子树代替z的位置** 
3. 如果结点z有两棵子树，则令z的直接后继（或直接前驱）代替z，然后从BST中删除这个直接后继（或直接前驱）回到1或2的情况



<br>



 **补充：在BST中删除再插入一个结点，得到的BST和原来的不一定相同** 

如果是叶节点就是相同



<br>



 **BST的查找效率分析：** 



<br>



### 7.3.2 平衡二叉树（AVL）



<br>



### 7.3.3 红黑树



<br>



## 7.4 B树和B+树

### 7.4.1 B树

又称 **多路平衡查找树** ， B树中所有 **结点的孩子个数的最大值** 称为B树的 **阶** ，记作 **m** 

一棵m阶B树或为空树，或为满足以下性质的m叉树：

- 结点 **最多有m棵子树** （ **m-1个关键字** ）
- 如果 **根结点** 有孩子， **至少有两棵子树** 
- 除根结点外，所有非叶结点至少有 **m/2上取整棵子树** （ **m/2上取整-1个关键字** ）
- 非叶结点由 **指向子树的指针** 和 **关键字** 交错组成，且有递增次序，关键字左边子树的关键字都小于它，右边都大于它
- 所有叶结点均在同一层，且无信息，类似于查找失败结点（指针是空指针），实际上不存在

下图是一棵5阶B树：



<br>



**1、B树的高度（磁盘存取次数）**

**B树的高度不包含最下面的叶结点**

B树的操作所需的 **磁盘存取次数** 和 **B树** 的高度 **成正比** 



<br>



**2、B树的查找**

和二叉排序树类似，但是B树的 **每个结点都是包含多个关键字的有序表** ，且 **进入其子结点需要走多路分支** 

B树的查找过程：

1. 在B树中找结点：在 **磁盘** 中进行，因为B树多存储在磁盘上
2. 在结点中找关键字：找到结点后，会将结点信息存入内存，在 **内存** 中进行，采用顺序或者折半查找
3. 查找到叶结点时（对应指针是空指针），查找失败



<br>



**3、B树的插入**





<br>



### 7.4.2 B+树



<br>



## 7.5 散列表

散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为 `Hash(key) = Addr` ， 可以是内存地址，数组下标，索引等。



<br>

# 第八章 排序



### 重点

- 堆排序、快排、归并排序
- 各种算法的思想、手动模拟过程、性质（初态的影响、 **复杂度** 、稳定性、适用性）
- 各种算法的对比，能根据情况选择最佳算法
- 代码实现



<br>



### 8.1.1 排序的基本概念



 **算法的稳定性** ： 如果两个关键字相同的元素，在排序之后顺序不变，则称为 **稳定** ，否则就是 **不稳定** 

 **内部排序** ：排序期间元素全部存放在内存中
 **外部排序** ：排序过程中，元素需要在内、外存之间移动的排序



内部排序：

- 插入排序： **直接插入排序** 、 **折半插入排序** 、 **希尔排序** 
- 交换排序： **冒泡排序** 、 **快速排序** 
- 选择排序： **简单选择排序** 、 **堆排序** 
- 归并排序
- 基数排序

外部排序：



<br>



### 习题

 **选择题** ：

1. 对任意7个关键字进行基于比较的排序，至少需要进行 **13** 次关键字之间的两两比较

   **解释** ： 

   

<br>



## 8.2 插入排序

 **基本思想** ： 

将一个待排序的记录按其关键字大小插入 **前面已经排好序的子序列** ，直到所有记录插入完成



<br>



### 8.2.1 直接插入排序

**算法的步骤：**

对A[1~n]进行排序（默认是按非递减顺序）， A[0]作为临时变量用于暂存

循环 i 从 2 ~ n（ **将A[1]视作已经完成排序的子序列** ）

1. 将A[i]暂存到A[0]
2. 循环已经完成排序的子序列的A[1~i-1]，找到合适的插入位置 k
3. 将A[j~i-1]中所有元素依次 **向后移动一位** ，将A[0]的值复制到A[k]

<br>



**c++代码：**

```c++
// 直接插入排序
void InsertSort(int a[], int n){
    
    for(int i = 2, j; i <= n; i++ ){
        if(a[i] < a[i-1]){
            // a[0]作为临时变量, 用于保存a[i]
            a[0] = a[i];
            
            // 第二重循环, 在已排好序的子序列中从后往前找到插入位置
            for(int j = i-1; a[0] < a[j]; --j ){
                // 向后挪一位
                a[j+1] = a[j];
            }
            // 插入到合适的位置
            a[j+1] = a[0];
        }
    }
}
```



<br>



**直接插入排序的手动模拟：**

![第八章_直接插入排序](assets/数据结构笔记/第八章_直接插入排序.PNG)

<br>



 **直接插入排序的性能分析：** 

- 空间复杂度：只用了一个临时变量A[0]， **空间复杂度O(1)** 
- 时间复杂度：总共循环了n-1趟，每趟都需要执行 **比较** 和 **移动** ，比较和移动次数和 **初始状态相关** 
  -  **最好情况下** ：表中元素 **已经有序** ， 此时只需要比较一次而不需要移动， **时间复杂度O(n)** 
  -  **最坏情况下** ：表中元素逆序， **时间复杂度O(<img src="http://chart.googleapis.com/chart?cht=tx&chl= n^{2}" style="border:none;">)**  
  -  **平均情况下** ： 两重循环， **时间复杂度O(<img src="http://chart.googleapis.com/chart?cht=tx&chl= n^{2}" style="border:none;">)**  
- 稳定性：稳定
- 适用性：适用于 **顺序存储** 和 **链式存储** 的线性表，适用于 **基本有序的排序表或者数据量不大的排序表**



<br>



### 8.2.2 折半插入排序

 **是在直接插入排序的基础上的改进** 

直接插入排序的 **从已完成排序的子序列中查找插入位置** ，这一步 **从顺序查找改为折半查找** 



<br>



**c++代码：**

```c++
// 折半插入排序
void InsertSort_2(int a[], int n){
    
    for(int i = 2, j; i <= n; i++ ){
        // 将a[i]暂存到a[0]
        a[0] = a[i];
        
        // 折半查找到合适的插入位置
        int low = 1, high = i - 1;
        while(low <= high){
            int mid = (low + high) / 2;
            if(a[mid] > a[0])
                high = mid - 1;
            else
                low = mid + 1;
        }
        
        // 向后移动一位, 然后将a[0]插入
        for(int j = i - 1; j >= high + 1; --j )
            a[j+1] = a[j];
        a[high + 1] = a[0];
    }
}
```



<br>



 **折半插入排序的性能分析：** 

- 空间复杂度：只用了临时变量a[0]，空间复杂度O(1)
- 时间复杂度：减少了比较次数，元素移动次数没有改变。 **时间复杂度O(<img src="http://chart.googleapis.com/chart?cht=tx&chl= n^{2}" style="border:none;">)**  
- 稳定性： **稳定** 



<br>



### 8.2.3 希尔排序

又称 **缩小增量排序** ， 是对 **直接插入排序** 的改进

**基本思想：**

将待排序表分为若干个 **组** ，每个字表由相隔某个 **增量** 的记录组成，然后 **对每个组进行直接插入排序** 

然后缩小增量（一般是除以二），当最后增量为1时，相当于对整个表进行一次直接插入排序



<br>



**c++代码：**

```c++
// 希尔排序
void Shell_Sort(int a[], int n){
    
    // 步长变化
    for(int dk = n / 2; dk >= 1; dk /= 2){
        for(int i = dk + 1; i <= n; ++i ){
            if(a[i] < a[i - dk]){
                a[0] = a[i];
                // 记录后移, 找到插入的位置
                for(int j = i - dk; j > 0 && a[0] < a[j]; j -= dk)
                    a[j + dk] = a[j];
                // 插入
                a[j + dk] = a[0];
            }
        }
    }
    
}
```



<br>



**希尔排序的手工模拟：**

![第八章_希尔排序](assets/数据结构笔记/第八章_希尔排序.PNG)



<br>



**希尔排序的性能分析：**

- 空间效率：只用了a[0]作为临时变量， **空间复杂度O(1)** 
- 时间效率：最坏情况下 **时间复杂度O(<img src="http://chart.googleapis.com/chart?cht=tx&chl= n^{2}" style="border:none;">)**  ，一般情况下和增量序列的函数有关
- 稳定性： **不稳定** 
- 适用性： **仅适合于用线性表的顺序存储** 



<br>



## 8.3 交换排序

指的是根据两个元素的关键字值的大小对这两个元素的位置进行对换。重点在 **快速排序** 



<br>



### 8.3.1 冒泡排序

**基本思想：**

 **从前往后（或者从后往前）** 两两比较相邻元素的值，如果是逆序，就进行交换，这个过程称为 **一趟冒泡** ，一趟冒泡能使得 **将未排序序列中最大的（或者最小的）放到它的位置** ，已完成排序的元素不参与下一趟排序。

**一趟冒泡能使一个元素确定它的位置，最多需要n-1趟将所有元素排序完成** 



<br>



**冒泡排序的手动模拟：**



<br>



**c++代码：**

```c++
// 冒泡排序 将小的冒泡到前面
void bubble_sort(int a[], int n){
    // 总共n-1趟冒泡
    for(int i = 0; i < n - 1; i++ ){
        bool flag = false;  // 本轮是否发生交换的标志
        
        for(int j = n - 1; j > i; j-- ){
            if(a[j - 1] > a[j]){
                swap(a[j - 1], a[j]);
                flag = true;
            }
        }
        // 本趟没有交换 说明已经有序, 提前退出循环
        if(flag == false)   return;
    }
}
```



<br>



**冒泡排序的性能分析：**

- 空间复杂度： **空间复杂度O(1)** 
- 时间复杂度：
    -  **最好** ：当循环初始有序，第一趟冒泡之后，没有发生交换，直接跳出循环，比较次数为n - 1， **时间复杂度O(n)**
    -  **一般** ： 两重循环， **时间复杂度O(<img src="http://chart.googleapis.com/chart?cht=tx&chl= n^{2}" style="border:none;">)**  
    -  **最坏**：初始逆序，  **时间复杂度O(<img src="http://chart.googleapis.com/chart?cht=tx&chl= n^{2}" style="border:none;">)**  
- 稳定性：当两个元素相等时，不会触发交换的条件，所以 **稳定** 



<br>



**补充：** 冒泡排序产生的有序子序列一定是全局有序的（直接插入排序的是相对的）

<br>



### 8.3.2 快速排序

**基本思想：**

快速排序基于 **分治** ，每次从待排序表 `a[l, r]` 中选择一个元素作为枢轴 `pivot` ，**一趟快速排序（也称为划分）结束后，pivot左边的元素都小于等于它，pivot右边的元素都大于等于它，pivot放到了它的最终位置上** 。

然后递归对两个子表进行操作，直到每个字表只有一个元素或者为空为止， 最终排序完成。

一趟快速排序是 **搜索+交换** 的过程



<br>



**快速排序的手工模拟：**



<br>



**快速排序的c++代码：**

```c++
// 一趟划分, 返回最终pivot的位置
int Partition(int a[], int low, int high){
    int pivot = a[low]; // pivot可以选择左边界、右边界或者中点
    
    while(low < high){
        // 将比pivot小的元素都移动到左端, 比pivot大的都移动到右端
        while(low < high && a[high] >= pivot) --high;
        a[low] = a[high];
        while(low < high && a[low] <= pivot) ++low;
        a[high] = a[low];
    }
    a[low] = pivot; // 将pivot放到最终位置
    return low;
}

// 快速排序
void quick_sort(int a[], int low, int high){
    if(low < high){
        // 枢轴的位置
        int pivot_pos = Partition(a, low, high);
        
        // 递归两个子区间
        quick_sort(a, low, pivot_pos);
        quick_sort(a, pivot_pos + 1, high);
    }
}
```



<br>



**快速排序的性能分析：**

- 空间复杂度：和递归工作栈的深度成正比。
    - 最好情况：O(logn)
    - 最坏情况：进行n-1次递归，O(n)
    - 平均情况：O(logn)
- 时间复杂度：运行时间和划分是否对称有关，当表初始有序或者逆序时，最坏的 **时间复杂度O(<img src="http://chart.googleapis.com/chart?cht=tx&chl= n^{2}" style="border:none;">)**  
- 稳定性： **不稳定** ，例如右边有两个值相等的小于pivot的元素，交换到左边时，次序已经发生了变化



<br>



注意：快速排序不产生有序序列，但 **每趟能将一个元素（枢轴）放到最终位置上** 



<br>



**快速排序的改进：**

提高算法的效率，可以通过尽量选取一个能将区间中分的pivot，例如可以从左边界元素、中间元素、右边界元素中选择中间值作为pivot



<br>



## 8.4 选择排序

 **基本思想** ： 每一趟（例如第i趟）从后面的 `n-i+1` 个待排序元素中选取关键字最小的元素，作为有序子序列的第i个元素。最终n-1趟之后，排序完成

 **重点** ： **堆排序** 



### 8.4.1 简单选择排序

**基本思想：**

初始序列为a[1…n]， 假设当前是第i趟排序，从a[i…n]中选择关键字最小的元素与 `a[i]` 交换，每趟排序可以确定一个元素的最终位置，n-1趟后整个排序表有序



<br>



**c++代码：**

```c++
// 简单选择排序
void Select_sort(int a[], int n){
    // 需要n-1趟排序
    for(int i = 0; i < n - 1; i++ ){
        // min记录待排序序列中最小元素的下表
        int min = i;

        // 找到待排序区间[i, n-1]中的最小元素的下标
        for(int j = i + 1; j < n; j++ ){
            if(a[j] < a[min])
                min = j;
        }

        if(min != i) swap(a[i], a[min]);
    }
}
```



<br>



**简单选择排序的效率分析：**

- 空间效率：时间复杂度O(1)

- 时间效率：swap()函数会移动元素3次，因此最坏情况下元素会移动 `3(n-1)` 次，最好情况（表已经有序）下移动0次；但比较次数始终是 `n(n-1)/2` ， 因此  **时间复杂度O(<img src="http://chart.googleapis.com/chart?cht=tx&chl= n^{2}" style="border:none;">)**  

- 稳定性：不稳定



<br>



### 8.4.2 堆排序

**堆的定义：**

如果将一维数组视为一棵完全二叉树，满足任一非根结点的关键字都小于等于其双亲的结点值，此时树中最大元素是是树的根结点，此时称这个数据结构为 **大顶堆** ，反过来可以定义 **小顶堆** 

**堆排序的基本思路：**

1. 将 `a[1…n]` 组建大顶堆，此时a[1]就是整个堆中的最大值
2. 交换 `a[1]` 和 `a[n]` （也就是将堆顶输出），此时讲 `a[n]` 视为完成排序的序列，将 `a[1…n-1]` 调整为堆，再输出堆顶
3. 重复，直到堆中只剩一个元素为止，此时完成排序

**堆排序的重点：如何自上而下调整为堆？** 



<br>



**堆的调整的手工模拟：**



<br>



**堆排序的c++代码：**

```c++
// 将以k为根的子树调整为堆
void HeapAdjust(int a[], int k, int len){
    // a[0] 暂存根结点
    a[0] = a[k];

    // 沿key较大的子结点向下筛选
    for(int i = 2 * k; i <= len; i *= 2){
        // 选取key较大的子结点的下标
        if(i < len && a[i] < a[i + 1])
            i++;

        // 筛选结束
        if(a[0] >= a[i]) break;
        else{
            // 将a[i]的值换到双亲结点上, 修改k的值, 方便向下筛选
            a[k] = a[i];
            k = i;
        }
    }
    // 将筛选结点放到最终位置
    a[k] = a[0];
}

// 建立大顶堆: 从 len/2 往前反复调整堆
void BuildMaxHeap(int a[], int len){
    for(int i = len / 2; i > 0; i-- )
        HeapAdjust(a, i, len);
}

// 堆排序
void heap_sort(int a[], int len){
    // 建立大顶堆
    BuildMaxHeap(a, len);
    
    // n-1趟交换和调整为堆的过程
    for(int i = len; i > 1; i-- ){
        // 输出堆顶（和堆底元素交换, 加入完成排序的序列）
        swap(a[1], a[i]);
        // 将未排序序列 a[1, i-1]调整为堆
        HeapAdjust(a, 1, i-1);
    }
}
```



<br>



**堆排序的性能分析：**

- 空间效率：仅使用了常数个辅助单元，空间复杂度 **O(1)** 
- 时间效率：建堆的时间是O(n)，然后有n-1次调整操作，每次调整的时间复杂度和树高有关：O(logn)，总的时间复杂度： **O(nlogn)** 
- 稳定性： **不稳定** 



<br>



## 8.5 归并排序和基数排序



### 8.5.1 归并排序

**基本思想：**

 **归并** 是将2个或者两个以上的有序表组合成一个新的有序表。

待排序序列可以视为n个长度为1的有序子表，可以通过两两归并，得到 `n/2上取整` 个子表。重复操作，直到合成一个长度为n的有序表为止（像合成大西瓜-=）。一次合并两个子表的排序称为 **2路归并排序** ，它也是基于 **分治** 的

**步骤：**

1. 确定分界点mid： `mid = (l + r) / 2` 
2. 递归左右两个子区间： `[l,mid]` 和 `[mid+1, r]` 
3.  **重点** 归并，将两个有序数组合二为一。循环，每次用 **双指针** 找到两个有序数组当前的最小值，放入临时数组中



<br>



**二路归并排序的手工模拟：**



<br>



**c++代码：**

```c++
// 归并排序
void merge_sort(int a[], int l, int r){
    if(l >= r) return;
    
    int mid = (l + r) / 2;
    
    merge_sort(a, l, mid), merge_sort(a, mid + 1, r);
    
    // k是辅助数组的下标 ij是双指针, 每次选两个数组中当前更小的元素加入tmp中
    int k = 0, i = l, j = mid + 1;
    while(i <= mid && j <= r){
        if(a[i] < a[j]) tmp[k++] = a[i++];
        else tmp[k++] = a[j++];
    }
    
    // 如果有表未检测完, 补上去 两个while最多只要一个会执行
    while(i <= mid) tmp[k++] = a[i++];
    while(j <= r) tmp[k++] = a[j++];
    
    // 最后把元素从tmp中拿回来
    for(int i = l, j = 0; i <= r; i++, j++) a[i] = tmp[j];
    
}
```



<br>



**2路归并排序的性能分析：**

- 空间效率：需要一个 `tmp[]` 临时数组来保存所有元素， **空间复杂度O(n)** 
- 时间效率：每趟归并时间复杂度O(n)，（两个数组每次找最小的放进临时数组），总共需要 `log2n上取整` 次归并，因此时间复杂度O(nlogn)
- 稳定性：归并操作不会改变相同关键词的元素的相对次序，因此 **稳定** 



<br>



### 8.5.2 基数排序

 **基本思想：**

基数排序基于 **关键字各位的大小** 进行排序。基数排序的思想借助了 **多关键字排序** ，来对单关键字进行排序



<br>



**基数排序的手工模拟：**



<br>



**基数排序的性能分析：**

- 空间效率：一趟排序需要的辅助空间为 `r` ， (r个队列：r个队头指针和r个队尾指针)，之后每趟排序也是用这些队列， **空间复杂度O(r)** 
- 时间效率：d趟分配和收集，一趟分配需要O(n)，一趟收集需要O(r)，基数排序的 **时间复杂度O(d(n+r))** 。  **和初始状态无关** 
- 稳定性：按位排序保证了 **稳定** 



<br>



## 内部排序算法的比较

一般比较三个因素： **时空复杂度** 、 **稳定性** 、 **算法的过程特征** 

![第八章_各种排序算法的性质](assets/数据结构笔记/第八章_各种排序算法的性质.png)





<br>



## 内部排序算法的应用

通常情况下，选择排序算法需要考虑：

1. 待排序元素数目n
2. 元素本身信息量的大小
3. 关键字的结构及其分布
4. 稳定性
5. 语言、存储结构和辅助空间大小



<br>



**总结：**

- 当 **n较小** 时，可选 **直接插入** 或 **简单选择** ，且简单选择的元素移动次数比直接插入少，当 **元素本身信息量较大** 时，选 **简单选择** 

- 当 **初始状态已经按关键字基本有序** ，选 **直接插入** 或者 **冒泡** 

- 当 **n较大** 时，应该采用 **时间复杂度O(nlogn)** 的算法： **快排** 、 **堆排序** 、 **归并排序** 

    - 快排是基于比较的排序中性能最好的，当 **待排序的关键字随机分布** 时，选 **快排** ，最快
    - 若要 **辅助空间最小** ，选择 **堆排序** 。且 **堆排序不会有最坏情况** 
    - 若要求排序 **稳定** ，选 **归并排序** 
    - 若 **记录的关键字位数较少且可分解** 时，采用 **基数排序** 

- 任何基于 **比较** 的排序算法，至少需要 **O(nlogn)** 的时间

- 记录本身信息量较大时，可以用 **链表** 来存储来减少移动元素所需要的大量时间

    



<br>



### 习题

**选择题：**





<br>



**应用题：**

1. 设关键字序列为 `{3, 7, 6, 9, 7, 1, 4, 5, 20}` ，对其进行排序的最小交换次数是多少？

2. 顺序表用数组 `A[]` 表示，表中元素存储在下标 `1~m+n` 。前m个元素递增有序，后n个元素递增有序，设计一个算法，使得整个顺序表有序。

    1）说明基本思想

    2）用c/c++描述算法

    3）说明时空复杂度

3. 有一种简单的排序算法，称为 **计数排序** （count sort）。对一个待排序的表进行排序，结果存到另一个表中。（保证没有重复元素）计数排序针对表中的每一条记录，扫描待排序的表一趟，假设统计出c个元素比当前元素小，那就将这个关键字放到c表的下标c的位置上

    1）设计实现计数排序的算法

    2）对于有n个记录的表，关键字的比较次数是多少？

    3）和简单选择排序相比，计数排序是否更好？为什么？

4. 设有一个数组中存放了一个无序的序列k1~kn。现在要求将kn放在元素排序之后的正确位置上，试编写实现该功能的算法，要求关键字比较次数不超过n

    





<br>



## 8.7 外部排序

考查概念、方法、排序过程





<br>



---



### 小工具

```
<img src="http://chart.googleapis.com/chart?cht=tx&chl= 在此插入Latex公式" style="border:none;">
```

