参考书籍：C语言程序设计 何钦铭（第三版）

<hr>

# 一、 数据表达与组织

## 1.1 常量、变量、运算、表达式

**C语言标识符** ：由 `字母` 、 `数字` 、 `下划线` 组成，且必须是 `字母` 或 `下划线` 开头，且 **区分大小写**

标识符分为：

- **关键字（保留字）** ： 如 `typedef` 、`int` 、 `if` 、 `return` 等
- **用户定义的标识符**



<br>



**C语言中的数据类型：**

- **整型** 
    - 有符号整形 (`int` 、 `short` 、 `long` 、 `long long` )：int占4字节
    - 无符号整形 ( `unsigned int` 等)
- **字符型 (char)** ：表示单个字符，用单引号占一字节，本质是该字符表示的ASCII值（整型）
    - 'A'：65 ， 'a'：97
- **浮点型(实型)**
    - 单精度float
    - 双精度double    `%08.3f\n` 表示显示8位数（包含小数点）， 不足8位用0填充，且保留3位小数
- **布尔(_Bool)**
    - 1表示 `true` ，0表示 `false` 



<br>



**关于字符串：**

c语言中没有字符串类型，但有字符串的概念，同时 `string.h` 中也有着相关操作字符串的函数

字符串（常量）是以NULL结尾的0个或多个字符组成的序列，常量所以不可修改，并用双引号，例如 `"Hello!"` ， `"123abc\n"`

字符串结尾默认有个空字符 `'\0'`

字符串常量与指针关系密切

因为字符串常量的值，实际上表示的是 **存储这些字符的内存空间的地址** ，更准确地说是 **字符串常量中第 1 个字符的地址** ，而 **不是这些字符本身**

因此，在 C 语言中不能直接进行字符串赋值，常通过声明一个指向 char 类型的指针并将其初始化为一个字符串常量的方式来访问一个字符串：

```c
char *msg = "Hello World!";
 
// 上面的语句也可以拆分成下面两句
char *msg;
msg = "Hello World!";　　　　// 这句话看起来像是字符串复制，其实不是，只是涉及到指针操作

// 可以进行遍历
while(*msg != '\0'){
	printf("%c ",*msg++);
}
```



<br>



**关于字符数组：**

在 C 语言中，除了字符串常量外， **其他所有字符串都必须存储于字符数组或动态分配的内存中**

定义和普通数组一样，只不过存放的元素是char类型的

```c
// 声明并初始化一个字符数组 下面两个效果一样
char str[] = {'H','e','l','l','o'};    
char str[] = "Hello World!";

// 可以进行修改 将小写变大写
for(int i = 0; i < strlen(str); i++){
	if( str[i] <= 'z' && str[i] >= 'a')
		str[i] = str[i] - 32;
}
```



<br>



**字符串常量和字符数组的区别：**

- 字符串常量是一个字符数组，但是内容和长度在初始化时就已经固定了， **不可更改** ；可以通过一个指向字符串常量第一个元素的指针来访问该字符串常量；

- 字符数组是一个用于存放字符的数组，字符数组的值是 **可以更改的** 



<br>



**常量** ：程序运行中不能被改变的量

**变量** ：程序运行中可以被改变的量

```c
// 声明一个变量
类型说明符 变量名A, 变量名B = B的初始值;
```



<br>



**运算：**

- **算术运算** ：`+` 、 `-` 、`*` 、`/（整除）` 、`%（只用于int）`（当双目运算符两边类型不同时，会自动进行类型转换）
- **赋值运算** ：`=` 左边必须是变量，右边计算完后会自动转化为左边的类型，再赋予左边
- **关系运算** ： `>` 、`<` 、 `!=` 等
- **位运算** ： 按位取反，按位与，左移右移等（操作数的移位不改变原操作数的值，除非通过赋值）

**（重要）运算符的优先级（数字越小越优先）和结合性（没写就是左到右，操作数两边的优先级相同时，先与左边的运算符结合）：**

1. 括号 `[]` 和 `<>` 、成员选择 `.` 和 `->` 
2.  `逻辑非!`     **右到左**
3. `单目-` ， `按位取反~` ， `自增++ 自减--` ，`指针取值*` ， `取地址&` ， `强制类型转换` ， `sizeof`    **右到左**
4. 乘，除，取模
5. 加，减
6. 左移<< ， 右移>> 
7. 大于，小于，大于等于，小于等于
8. 等于，不等于
9. 按位与&
10. 按位异或^
11. 按位或|
12. 逻辑与&&
13. 逻辑或||
14. 三目条件运算符 `?:`    **右到左**
15. 赋值运算符一类，包括 `=` ，`+=` 等    **右到左**
16. `,` 运算符

总结：

- 同一优先级的运算符，运算次序由结合方向所决定

- 简单记： `！> 算术运算符 > 关系运算符 > && > || > 赋值运算符`

    



<br>



**表达式：** 由运算符和操作数组成的有意义的运算式子

- 常量表达式：a

- 算术表达式：a+b

- 赋值表达式：a=1    **计算右边的值，再赋予左边，左边的值就是整个赋值表达式的值**

- 关系表达式：a>b    **关系表达式的值是整型，1或者0**

- 逻辑表达式：a&&b    **可以是任何类型，非0表示真，0表示假**

- 条件表达式：`a?b:c`

- 复合表达式

- 逗号表达式：`a,b` 按顺序执行，整个逗号表达式中每个语句都会被计算到，整个逗号表达式的值为最后一个表达式的值。作为条件的时候，非0真，0假

    ```c
    //执行时a的值会自增1，b的值也会自增1，最终将b自增后的值赋给变量z
    //此时z的值为5，也就是最终整个逗号表达式的结果。
    int a = 3,b = 4,z = 0;
    z = ++a,++b;	
    ```

    





<br>



## 1.2 一维和二维数组，字符数组和字符串

**一维数组：**

```c
类型名 数组名[数组长度];

// 初始化
int a[10] = {1, 2};	// a[0]的值是1, a[1]的值是2，其余元素默认是0
```

- 数组名是地址，是存放数组内存空间的首地址
- 数组长度是常量，下标从0~n-1
- 数组中的元素在内存中连续存放，数组名和下标可以唯一确定数组元素



<br>



**二维数组：**

```c
类型名 数组名[行长度][列长度];

// 初始化 按行
int a[4][3] = {{1, 2, 3}, {}, {4, 5}};
int a[4][3] = {1, 2, 3, 0, 0, 0, 4, 5};
```

- 二维数组在内存汇总按行/列优先存放
- 如果初始化时对全部元素赋值，或者分行赋值时列出了全部行，可以忽略行长度
- **一维长度可忽略，二维长度必须有**



<br>

1. **错误** a[1][2]是一行两列

    ```c
    int a[1][2] = {{1},{3}};
    ```

    

2. 可以在赋值语句中通过赋值运算符=对字符数组整体赋值 **错误**

    在赋值语句中通过赋值运算符"="对字符数组整体赋值，则就需要用到字符数组名，而对字符数组名进行操作时其会退化为常量指针，而进行赋值时左值必须是可以修改的变量。

    **初始化可以，赋值不行**

3. 



<br>



### 计算多维数组中 aij 的地址

**当数组 `a[m][n]` 按行优先**

```
Loc(a[i][j]) = 首地址 + [已经满多少行 + 当前列数] * 每个元素多少字节
```

**当数组 `a[m][n]` 按列优先**

```
Loc(a[i][j]) = 首地址 + [已经满多少列 + 当前行数] * 每个元素多少字节
```



例题：

设 `A[5][4][3]` 在内存中首地址为1000，每个元素占2个存储单元，按行优先存储，求`A[4][3][2]`的首地址（A的下标从0开始）

```
三维数组看做层号、行号、列号
那么A[4][3][2]中4、3、2分别对应这个点的层数、行号、列号
4说明之前有4层是满的(0123) 也就是4*(4*3) =  48
3说明之前有3行是满的(012) 也就是3*(3) = 9
2说明之前有2个元素 也就是2
位置为4*(4*3)+3*3+2=59

因此A[4][3][2]的首地址就是1000 + 59*2 = 1118
```



<br>



**字符数组**

```c
char str[10];
char t[6] = {'H', 'I'};	// 没赋初始值的元素为0，也就是'\0'
```

- 如果初始化时对所有元素都赋初值，可以忽略数组长度



<br>



### 习题

1. 已知 ‘9’ 的 ASCII 码是 57，‘a’ 的 ASCII 码是 97，‘A’ 的 ASCII 码是 65。

    以下程序结果是：`a5`

    ```c
    int main() {
        char a[40] = "a\065\0b";
        puts(a);
        return 0;
    }
    ```

    八进制转义为 `\0hh` ， 即为\0后面为两个数

    十六进制转义格式为 `\xhhh` ，即为\0后面为三个数

    `\065` 发生了转义， 变为了八进制数 `53` ，也就是ASCII值为53的字符，也就是 `5` , 后面的 `\0` 为结束符

    

2. 设有如下函数，期望返回一个字符串:

    ```
    char *p(int n)
    {   ______________________________
        return s+n;
    }
    ```

    该函数内的下划线处填入以下哪个选项时，将 **不能** 正确得到函数返回的字符串？(2分)	**B**

    ```c
    A. char *s="abcdefghij";
    B. char s[]="abcdefghij";
    C. static char s[]="abcdefghij";
    D. char *s; s=(char *)malloc(10); strcpy(s,"abc123");
    ```
    
    解释：
    
    





<br>



**字符串**

字符串常量是用 **双引号** 括起来的字符序列，以 `'\0'` 为结束符

字符串"happy"由6个字符组成，有效长度是5

C语言中字符串作为特殊的一维字符数组来处理

```c
// 以下等价
char s[3] = {'g', '0', '\0'};
char s[3] = {"go"};
char s[3] = "go";

char s[80];	// 80不影响, 因为遇到\0就结束了
s[0] = 'g';
s[1] = 'o';
s[2] = '\0';
```



<br>



## 1.3 指针与数组，结构与数组

#### 指针（重中之重）

C语言中，专门用来存放变量地址的变量称为 **指针**

```c
类型名 *指针变量名

// p是一个指针，指向一个int型的变量a（或者说p存放的是int型变量a的地址） a就是一个int型的变量
int a = 3;
int* p = &a;

// 这是一样的
int a = 3;
int* p;
p = &a;

// 如果a是数组名, 因为数组名就是地址
int* p = a;

// 就是n
*&n;
```

- 指针本身也是变量，只不过他存放的内容是别人的地址
- `*` 除了定义指针，还用于访问指针指向的变量，也称为 **间接访问运算符**
- *p：a的值
- p：a的地址



<br>



**取地址符合间接访问运算**

```c
int a = 3, *p;
p = &a;     // p指向a的地址 *p的值和a的值是一样的
printf("a=%d, *p=%d\n", a, *p); // 3 3

*p = 10;    // 修改p所指向的变量的值, 相当于对a赋值
printf("a=%d, *p=%d\n", a, *p); // 10 10

a = 5;
// *p = *p++或者++*p也是一样的效果
(*p)++; // 将指针所指向的变量+1
printf("a=%d, *p=%d\n", a, *p); // 6 6

// 而*p++的效果是*(p++)，先取*p的值,再将p的值(也就是a的地址)+1, 导致p不再指向a
*p++;
printf("a=%d, *p=%d\n", a, *p); // 6 114514
```



<br>



**赋值运算**

只能将一个指针的值（也就是地址）赋给另一个相同类型的指针

```c
int a = 3, *p1, *p2;
p1 = &a;
    
p2 = p1;	// 此时p1和p2都指向a, *p2、*p1、a访问同一个内存单元

// 赋初值
int *p = 1000; // 错误
int *p = 0;	// 正确 此处0就是ASCII的NULL 定义了一个空指针
```



<br>



#### 指针、数组和地址间的关系

数组名本身就是地址，也就是指针的值，在访问内存方面，数组和指针几乎是相同的

数组名可以看做特殊的固定地址

```c
int a[10], *p;

p = a + 1; // 正确
a = a + 1; // 错误
```

- a+i就是距数组a的基地址的第i个偏移
- *(a+i) 和 a[i] 等价
- **数组和指针的本质区别** ：数组a是指针常量，不是指针变量
- 如果p指向int型的变量，则p+1就指向int型的下一个变量的内存地址，p的值加上1个int类型的长度（2字节）
- 如果p和q都是指向数组元素的指针，p-q是int型的值，表示在p和q之间的元素个数
- 指针的算术运算中：只有链各个相同类型的指针相减和指针加上或减去一个整数是合法的，其他都是非法的



<br>



#### 数组名作为函数的参数

```c
// 传参时，传的其实是a的基地址，加上[]其实是习惯
int add(int a[], int n){	// int a[]等价于int *a
    int ans = 0;
    for(int i = 0; i < n; ++i)
        ans += a[i];
    return ans;
}	

// 调用
add(b, 10);		// 从b[0]加到b[9]
add(&b[7], k-7);	//从b[7]加到b[k-1] 
add(b+7, 2*k)	// 从b[7]加到b[2*k+6] 
```

- 第二个，从b[7]开始，注意项数数不变的
- 第三个，将b的地址偏移7，也就是从b[7]开始，b[7]传参变成a，函数执行过程中所有地址都会偏移7



<br>



#### 习题

1. 如果有变量定义`char **pp[10];`，那么下面说法正确的是：**D**

    - A `pp` 是指向字符指针的指针变量

    - B `pp` 是字符指针

    - C `pp[4]` 是字符指针

    - D `pp` 是数组名

    解答：首先看元素：数组中的元素类型是char**，也就是指针的指针，那么pp是指向元素的指针，他是3重指针，也是数组名



<br>



## 1.4 指针与结构，单向链表

#### 结构

自己定义的，包含的分量称为结构成员，可以是任意类型的

```c
// 结构体数组的初始化
struct sturdent{
    int num;
    char name[10];
}sturdents[50];
```

- 结构的定义以分号结束，结构的定义整体是一条语句
- 在嵌套定义时，必须先定义成员的结构类型
- 关键字struct和结构名必须一起用，整体为数据类型名
- 只有相同结构类型的变量直接才可以直接赋值
- 结构体内可以定义函数



<br>



**结构体数组**

对数组元素的成员的引用 数组下标和结构成员操作符组合实现

```c++
sturdents[2].num
```



<br>



#### 结构指针

结构指针就是指向结构类型变量的指针

```c++
struct stundent s1 = {27, "chen"}, *p;
p = &s1;

// 访问成员的两种方式 等价的
(*p).num = 28;	// *p表示p指向的结构变量, 点的优先级高于*, 因此需要括号
p->num = 28;
```



<br>



**结构指针作为函数参数**

```c++
// 定义
int update_score(struct student *p, int n){
    ...
}

// 使用
update_score(sturdents, n);
```

- 将结构数组的数组名（也就是结构体指针）传给形参p，在函数中就可以通过结构指针p对结构数组中的数据进行间接访问操作了
- 优点：使用结构指针作为参数只需要传一个地址，就可以操作结构体数组



<br>



#### 单向链表（单链表）

下面是一个定义的例子

```c++
// 定义一个Node结构体
struct Node{
    int key;
    struct Node *next;
};
// 创建一个Node结点
struct Node *p;
p = (struct Node*)malloc(sizeof(struct Node));


// 可以typedef起别名
typedef struct Node{
    int key;
    node *next;
    
    // 结构体内定义一个初始化的函数
    node(int _val) : key(_val), next(NULL) {}
}node;
// 创建一个Node结点
node* p = new LinkNode(x);
```

- next分量又是该结构类型的指针，称为结构的递归定义（c++在递归定义时可以不加struct）
- 链表相对于数组的有点：不用事先定义大小，可以动态分配，可以方便的插入新元素



<br>



**单链表的基本操作**

1. 遍历

    ```c++
    for(p = l; p; p = p->next){
        ...
    }
    ```

    - 结点在内存中不连续，因此不能用p++



2. 插入结点

    ```c++
    // 将p插到q的后面
    p->next = q->next;
    q->next = p;
    ```

    

3. 删除结点

    ```c++
    // 删除p后面的结点q
    p->next = q->next;
    free(q);
    ```

    

<br>



#### 习题

1. 对于以下变量的定义，正确的赋值是： **D**

    ```c
    int *p[3], a[3];
    
    A. p = a
    B. *p = a[0]
    C. p = &a[0]
    D. p[0] = &a[0]
    ```

    

2. 下面程序的输出是 **12**

    ```c
    int a[12] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, *p[4];
    for(int i = 0; i < 4; i++ )
    	p[i] = &a[i * 3];
    printf("%d\n", p[3][2]);
    ```

    p是指针数组，数组中的每个元素都是指针

    可以看到p[0] = &a[0]，p[1] = &a[3]， p[2] = &a[6]，p[3] = &a[9]

    而 `p[3][2]` 根据数组和指针的转换，相当于 `*(p[3] + 2)` 也就是p[3]的值（a[9]的地址）往后移动2个单位（a[11]）的值

    ```c
    p[2]相当于*(p+2)
    p[3][2]相当于*(p[3] + 2)
    ```

     

3. 下列程序的输出结果是 **efgh**

    ```c
    char *fun(char *t){
    	char *p = t;
    	return (p+strlen(t)/2);
    }
    
    int main(){
    	char *str = "abcdefgh";
    	str = fun(str);
    	puts(str);
    }
    ```

    strlen(t)/2就是t的长度除以2

    相当于返回p+4，指针向后移动4位，就是从下标4开始后面的值

    ```c
    char str[] = "abcdefgh";	// str字符数组, 内容可以修改
    
    char *str = "abcdefgh";		// str是指向字符串的指针, 内容不可修改
    ```

    

4. 设有如下定义的链表，则值为7的表达式是 **(++p)->n**

    ```c
    struct st{
    	int n;
    	struct st *next;
    }a[3] = {5, &a[1], 7, &a[2], 9, NULL}, *p=&a;	// 这里应该是*p=a比较合理
    ```

    p指向的是a数组的首地址，++p就是第二个元素，第二个元素的n成员就是7

    ```c
    a       表示数组元素的首地址，同时也可做为数组的指针使用	a+1 为数组的第二个元素地址
    &a      表示整个数组的首地址							 &a+1 跳过整个数组后的地址
    &a[0]   表示数组第一个元素的地址						&a[0]+1 同a+1
    ```

    

5. 

    





<br>

<br>

<br>



# 二、语句和流程控制

## 2.1分支控制（if、switch）

**if的一般形式：**

```c
if(表达式1) 语句1;
else if(表达式2) 语句2;
else 语句三;
```



<br>



**switch的一般形式：**

```c
switch(表达式){
    case 常量表达式1: 
        语句1; 
        break;
        
    ...
        
    case 常量表达式n:
        语句n;
        break;
    default:
        表达式n+1;
        break;
}
```

- 先求解switch()中的表达式
- 根据表达式的结果，找到对应的case，执行对应的语句段。 **如果没有break，会执行下面所有的代码**
- 如果case都不满足，就执行default，default可以省略，表示什么都不做



<br>



程序输出结果是：

```c
int k=2, s=0; 
switch(k) { 
    case 2: 
        s++; 
        k++;
    case 1: 
        s++; 
    case 3: 
        s+=1; 
    
    switch(s){ 
        case 2: 
            s+=2; 
            break; 
        default: 
            k++; 
            break; 
    } 
    default: 
        s+=3; 
} 

printf("%d#%d#", s, k);
```

结果是 `6#4#`



<br>



## 2.2 循环控制(for、while、do-while)

**for的一般形式：**



```c
// 从哪儿开始；到哪儿结束；步子迈多大
for(表达式1; 表达式2; 表达式3){
	循环体
}
```

- for中根据 **循环控制变量** 来控制循环的执行
- 表达式1： 定义循环变量，只会在循环之前执行1次
- 表达式2： 判断循环变量的值，为真继续循环，为假循环结束
- 表达式3： 步长表达式，设置对循环控制变量的改变。每次循环体执行结束，就会执行表达式3



<br>



```c
int i;
for(i = 0; i < 10; i++ );  // for后面的;表示的是空语句
    
// 在i=9结束之后, 会执行i++使得i变为10, 下次循环时, 不满足表达式2，循环终止
// 最后i的值为10
printf("%d", i);   
```



<br>



最后i的值为：`5`

```c
for(i=1; i++ <4; );
```



<br>

 



**while的一般形式：**

```c
while(表达式){
	循环体
}
```

- 当表达式值为真时，就执行循环里面的语句
- 当表达式为假时，终止循环执行while的下一条语句



<br>



最后k和s的值为：`-1 6`

```
int k = 4, s = 0;
while(k--)s+=k;
```





<br>



**do-while的一般形式：**

```c
do{
	循环体
}while(表达式);
```

- 先执行循环体一次，然后判断条件
- 因此 **至少会执行一次循环体**



<br>

<br>

<br>

# 四、输入/输出和文件

## 4.1 标准输入和输出

### 4.1.1 标准输入 scanf()

引入头文件：

```c
#include<stdio.h>
```

一般格式为：

```c
scanf(格式控制字符串, 参数1, …… ，参数n)
    
例如：
scanf("x=%lf", &x);

scanf("%d%d", &n, &m); // 可以正确读入20 30，因为scanf在处理输入时，如果格式占位符不是%c，它就会将空白字符（空格符、制表符和换行符）都视为一次输入的终止标记
scanf("%c %c", &n, &m);// 如果是%c,需要加上空格，否则m会变为空格
```

- 格式控制字符串用 **双引号** ， 包含：
    - `格式控制说明(格式占位符)` ：例如 `int型` 需要 `%d` ， `float` 需要 `%f` ， `double` 需要 `%lf`
    - `普通字符` ：原样输入的字符，一般会尽量避免在scanf中使用普通字符
- 参数是变量的地址
- 参数和格式控制说明要一一对应







<br>



### 4.1.2 标准输出 printf()

引入头文件：

```c
#include<stdio.h>
```

一般格式为：

```c
printf(格式控制字符串, 参数1, …… ，参数n)
    
// 输出浮点型时的格式控制
%+a.bf    
%-a.blf
a:输出数据的宽度 不足补空格
b:小数位
+: 右对齐 不写默认是右对齐
-: 左对齐
printf("%3.3lf\n",1.3345);    //有效小数位数是 3 位 最后一位5没有打印,四舍五入往前进了一位
```

- 格式控制字符串用 **双引号** ， 包含：
    - `格式控制说明(格式占位符)` ：例如 `int型` 需要 `%d` ， `float` 和 `double` 需要 `%f`
    - `普通字符` ：原样输出的字符
- 参数是输出的数据，可以是常量、变量、表达式
- 参数和格式控制说明要一一对应



<br>

格式占位符：

|   **于有符号整型**   | **%d or %i** |
| :------------------: | :----------: |
|     **用于字符**     |    **%c**    |
|    用于无符号整型    |      %u      |
|   **用于单浮点数**   | **%f or %F** |
| **用于双精度浮点数** |   **%lf**    |
|    **用于字符串**    |    **%s**    |





<br>



| 常用的转义字符 |                   效果                   |
| :------------: | :--------------------------------------: |
|       \n       |                   换行                   |
|       \r       | 换行(回到当前行首)，判断按键是否是回车键 |
|       \t       |                 水平制表                 |



<br>



## 4.2 文本文件和二进制文件

### 4.2.1 文件的定义：

C语言中的文件类似于数组、结构等，是一种数据组织方式，是C语言程序处理的对象

C语言把文件看作数据流，并按一维方式组织存储（像磁带）



<br>



### 4.2.2 文本文件、二进制文件

**文本文件/字符文件** ： 以字符ASCII码值进行存储和编码的文件，内容就是字符

**二进制文件** ： 存储二进制数据的文件

C语言的 **目标文件（.o）** 和 **可执行文件（.exe）** 是二进制文件，包含给计算机识别的机器代码





<br>



## 4.3 文件打开、关闭、读写和定位

**文件缓冲系统：**

进行文件操作时，在程序和文件之间的一个内存缓冲区，来进行数据交换

缓冲文件系统中，系统 **自动分配** 一块文件缓冲区（内存单元），且数据处理只考虑文件缓冲区即可，内存和磁盘之间是操作系统的事



<br>



### 4.3.1 文件处理步骤

1. 定义文件指针  `FILE *fp` ，fp为指向文件结构的指针， 注意不能用fp++和*fp
2. 打开文件：文件指针指向磁盘文件缓冲区
3. 文件处理：对文件进行读写操作
4. 关闭文件



<br>



### 4.3.2 打开文件

打开文件操作由 `fopen()` 实现

```c
FILE fp;
fp = fopen("文件名", "文件打开方式");
```

- 成功，返回包含文件缓冲区等信息的FILE结构地址，赋予文件指针fp；否则（文件不存在，被其他软件打开，本身错误等等）返回一个NULL的FILE指针
- 文件名是字符串，指明文件的路径：默认是当前的文件夹，否则就是完整路径，例如 `c:\\abc.txt` 此处用了转义符

关于文件打开方式：

（下面是 **文本文件（ASCII）** 的文件打开方式）：

| 使用方式 |           含义           |
| :------: | :----------------------: |
|    r     |   打开文件， **只读**    |
|    w     | **新建** 文件， **只写** |
|    a     |   打开文件， **追加**    |
|    r+    |     打开文件，读/写      |
|    w+    |   **新建** 文件，读/写   |
|    a+    |   打开文件，读/写/追加   |

- 只有w是新建，其他都是打开
- +代表功能的增加
- 对应的换成二进制文件只要加个b，例如从 `w+` 变为 `wb+`
- 文件打开的实质是将磁盘文件和文件缓冲区对应
- 打开之后，对文件的读写操作只需要使用文件指针，且已经打开，操作方式就已经被确定，关闭之前都不能改变
- 可以同时打开多个文件，但不允许同一个文件在关闭之前被再次打开



<br>



例如打开文件abc.txt，只读的两种方式：

```c
fp = fopen("abc.txt", "r");	// 字符串常量代表文件

char *p = "abc.txt";	// 字符指针表示文件
fp = fopen(p, "r");

if((fp = fopen("abc.txt", "r")) == NULL){
   	文件出错;
    exit(0);	//exit(0) 是系统标准函数, 关闭所有打开的文件并终止程序。0表示正常结束, 其他表示非正常结束
}
```



<br>



### 4.3.3 关闭文件

数据写入文件，首先是先写到文件缓冲区，缓冲区满（512B）才真正写到磁盘

在写满之前程序中止，这部分数据就会丢失

文件关闭可以强制使缓冲区中的数据写入磁盘

关闭文件操作由 `fclose()` 实现

```c
fclose(文件指针);
```

- 返回值为整数，0表示正常关闭
- fclose() 将释文件缓冲区单元和FILE结构，解除文件和文件指针的关联
- 文件使用结束完要及时关闭文件





<br>



### 4.3.4 文件读写

标准库stdio.h中的一些函数

#### 字符方式文件读写 fgetc() 和 fputc()

对于文本文件，操作的数据都是ASCII字符文本



```c
ch = fgetc(fp);	// 从fp指向的文件中读一个字符到ch, 只要成功, fp就会自动移到下一个位置。 失败, 返回EOF 	补充：类似getchar(), 从键盘中读一个字符
fputc(ch, fp);	// 将ch写到fp所指的文件		成功返回ch, 失败返回EOF(值为-1) 补充：类似putchar(), 将ch显示在屏幕
```

- 文件缓冲区中的位置会随着fgetc()和fputc()而自动改变
- 实际上是对文件缓冲区进行读写
- 不要在程序中用fp++来改变文件缓冲区的位置，fp指向的是文件结构

实现从A文件写数据到B文件：

```c
#include<stdio.h>
#include<stdlib.h>

int main(void){
    FILE *fp1, *fp2;
    char ch;
    
    // 打开两个文件
    if((fp1 = fopen("a.txt", "r")) == NULL){
        printf("a错误！\n");
        exit(0);
    }
    if((fp2 = fopen("b.txt", "w")) == NULL){
        printf("b错误！\n");
        exit(0);
    }
    
    // 进行复制 
    while(!feof(fp1)){  // feof()判断是否到了文件尾
        ch = fgetc(fp1);
        if(ch != EOF)   // 因为feof()在末尾之后再一个循环才会变成true 例如最后一个字符是'a'，此时feof是false，再读一次返回EOF，feof才是true
            fputc(ch, fp2);
    }
    
    // 关闭文件
    if(fclose(fp1)){
        printf("a 无法关闭！\n");
        exit(0);
    }
    if(fclose(fp2)){
        printf("b 无法关闭！\n");
        exit(0);
    }
    
    return 0;
}
```



<br>



#### 字符串方式文件读写  fgets() 和 fputs()

读写文件时以字符串为单位

```c
fgets(s, n, fp);	// 从文本中读字符串
```

- s不能为字符串常量
- fp是文件指针
- n为读取的字符个数，最多读取n-1个字符，并存入s指向的内存地址开始的n-1个连续单元
- 到指定个数、遇到换行符、EOF时，自动加上一个 `\0` ，换行符会保留，EOF不会保留
- 成功返回字符串；否则返回空指针，此时s中的内容不确定



```c
fputs(s, fp); 	// 向文件中写入字符串
```

- s可以是字符数组名、字符型指针变量、字符串常量
- fp是文件指针
- 写入的时候字符串结束符 `\0` 不写入
- 成功返回最后一个字符；否则返回EOF



<br>



#### 格式化方式读写 fscanf() 和 fprintf()



```c
fscanf(文件指针, 格式化字符串, 输入表);
fprintf(文件指针, 格式化字符串, 输入表);

// 从文件中读入整形n, 浮点型x
fp = fopen("a.txt", "r");
fscanf(fp, "%d%f", &n, &x);

// 将n和x写入文件
fp = fopen("b.txt", "w");
fprintf(fp, "%d%f", n, x);
```

- 类似于scanf()和printf()
- 格式转化计算机会自动完成



<br>



#### 其他相关函数：

和文件定位相关的函数：

- `rewind()` ：回到文件的首地址 `rewind(FILE *fp);`
- `fseek() ` ：控制文件读写指针移动 `fseek(fp, offset, from);` from可取012，表示开头、现在和末尾
- `ftell()` ：获取当前文件读写指针的位置，即相对开头的位移量 `ftell(文件指针)`

检测文件指针状态的函数：

- `feof()` ： 判断是否读到了EOF，成功返回true
- `ferror()`
- `clearerr()`



<br>

### 4.3.5 习题

1. `printf("%d %d %d", NULL, '\0', EOF);` 的结果是： **0 0 -1** 
2. 如果二进制文件a.dat已经存在，现在要求写入全新数据，应该用 **"wb"** 方式
3. `FILE *fp;` ，则文件指针指向的是 **文件类型结构**
4. 缓冲文件系统的文件缓冲区位于 **内存缓冲区中**
5. 文件的三大特征： **名称、大小、类型**
6. `fopen()` 的返回值是 **指向文件缓冲区的首地址的文件结构类型指针**
7. 缓冲文件系统和非缓冲文件系统的区别： **系统是否为文件自动分配一块文件缓冲区（内存单元）**



<br>

<br>

<br>



# 五、编译预处理和命令行参数

## 5.1 宏定义和宏函数

### 5.1.1 宏定义

通常用于符号常量定义，实现简单函数，或者为了书写更方便

目的为了增强代码可读性，减少函数调用成本

**格式：**

```c
#define 宏名 宏定义字符串
```

- 在编译预处理中起作用（编译时，将代码中有宏名的地方用宏定义字符串来 **替换** ），不是真正的C语句
- 末尾没有分号（有分号的话分号也会替换进去）
- 宏名中间无空格，宏定义字符串随意，回车符作为结尾
- 如果一行太长，可以用 `\` 下一行继续写

**可宏嵌套定义：**

```
#define PI 3.14
#define S PI*r*r
```



<br>



### 5.1.2 宏函数

```c
#define MAX(a, b) a>b?a:b

x = MAX(x, y);
```

**和函数调用的区别：**

- 宏定义在编译预处理时完成，进行替换。**宏定义只做替换，不做计算**
- 函数调用在程序执行时才进行，并且传参，**计算表达式后返回**

**为了防止出错，要加括号：**

```c
// y会变成x+y*x+y 出错
#define SQR(x) x*x
y = SQR(x+y);

// 替换时括号会保留 这样就不会出错
# define SQR(x) (x) * (x)
```

**配合逗号表达式：**

```c
// 这样会出错
#define ALERT(str)  {putchar('\a');puts(str);}
// 替换为 if(n) {putchar('\a');puts(str);};
if(1) ALERT("hhh");

// 正确 整个逗号表达式中每个语句都会被计算到 
#define ALERT(str)  {putchar('\a'),puts(str);}
// 替换为 if(n) {putchar('\a'),puts(str);};
if(1) ALERT("hhh");
```



<br>



## 5.2 typedef关键字

typedef 的作用是起别名

```c
// 一般用法
typedef  旧名字  新名字;

// 例子
typedef int *INTEGER;
INTEGER a, *b;	// 等价于int* a,*b;
```

- 相当于给int*起了个别名叫INTEGER
- a是 `int` 型的指针变量
- b是指向「指向整型的指针」的指针



<br>



### 5.2.1 和宏定义的区别

- typedef 仅限于为数据类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名
- 宏定义只是简单的字符串替换，由预处理器来处理
- 而 typedef 是在编译阶段由编译器处理，它并不是简单的字符串替换，而给原有的数据类型起一个新的名字，将它作为一种新的数据类型
  



<br>



## 5.3 命令行参数和使用

C语言源程序经过编译和连接生成可执行文件（可执行程序/可执行命令）后，可以在操作系统环境中用命令方式来执行

例如用命令 `test` 来执行当前目录下的 `text.exe`

而一个命令行中可以包括命令和参数（也可没用，用空格分开），这些参数就是 **命令行参数**

```
命令 参数1 参数2 
```

C语言中主函数可以有两个参数：

```c
int main(int argc, char *argv[]){}
```

- argc 为命令行参数（包括命令）的个数
- argv 以字符串常量方式存每个命令行参数：argv[0]是命令，argv[1]是参数1……
- argv实际上还是指针，指向数组的首地址，*argv是命令行参数，可以修改 `*(argv++)`
- 可以取其他名字，这两个是约定俗成



<br>



例如：

echo.c:

```c++
#include<stdio.h>

int main(int argc, char *argv[]){
	// 打印命令行参数
	for(int k = 1; k < argc; k++)
		printf("%s", argv[k]);
		
	return 0;
}
```

命令行下输入：

```
echo are you ok？
```

输出

```
are you ok？
```



<br>



## 5.4 习题

1. 如果有宏定义 `#define MUL(x,y) (x*y);` 那么表达式 `MUL(MUL(2+3,6),4+2)-7` 的值是：**75**

    宏展开时，从内到外

    ```c
    MUL(MUL(2+3,6),4+2)-7
    MUL((2+3*6),4+2)-7
    ((2+3*6)*4+2)-7
    ```

1. 假如下面程序的源程序文件名是 `echo.c`，编译链接后的可执行程序文件名是 `echo.exe`，那么执行命令 `echo How Are You?` 的输出是：**oe?d!**

    ```c
    #include <stdio.h>
    int main(int argc, char *argv[])
    {   int k, i=0;
        static char s[10]= "Good!";
        for(k = 1; k <argc; k++)  s[i++] = *(argv[k]+k);
        printf("%s", s); 	
        return 0;
    }
    ```
    
    - argv[1]的内容是 `How` ， argv[2]的内容是`Are` ， argv[3] 的内容是 `You?`
    - `*(argv[k]+k)` 就是 `argv[k][k]`





<br>



<hr>


<br>

<br>

<br>



# 六、基本算法设计与程序实现

## 简单排序算法

### 插入排序



<br>



### 选择排序



<br>



### 冒泡排序



<br>



## 二分查找

指针和数组的应用

```c
#include <stdio.h>

int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int x, m;

// 二分查找 用循环实现了递归
int Bsearch(int *p, int n, int x){
    int low = 0, high = n - 1, mid;
    
    while(low <= high){
        mid = (low + high) / 2;
        if(x == p[mid])
            break;
        else if(x < p[mid])
            high = mid - 1;
        else 
            low = mid+1;
    }
    if(low <= high) return mid;
    return -1;
}

int main(){
    printf("查找X:");
    scanf("%d", &x);
    
    m = Bsearch(a, 10, x);
    
    if(m >= 0)
        printf("Index is %d\n", m);
    else 
        printf("Not Found\n");
        
    return 0;
}
```

- a作为实参，在函数中就能访问a数组中的元素，并且也能改变单元的内容
- 可以采用数组形式，也可采用指针形式，例如 `p[mid]` 等价于 `*(p+mid)`





<br>

<br>

<br>



# 函数题

### 1、有序链表的并集与去重 (9分)

给定两个带头结点的严格降序的链表 `L1` 和 `L2`，要求你求两个链表的并集，其中元素仍然严格降序排列，且必须排除重复元素；重复的元素必须链成另一个降序排列的链表。完成去重合并后，并集链表的表头为 `L1`，重复元素链表的表头为 `L2`。

例如：`L1`→头结点→13→10→9→5；`L2`→头结点→15→10→5→2。

则合并后：`L1`→头结点→15→13→10→9→5→2；`L2`→头结点→10→5。

(这里把L1L2从下面指向头结点更好理解)

#### 函数接口定义：

```c++
void ListUnion( List L1, List L2 )
```

其中`List`结构定义如下：

```c++
// 给struct Node**起别名为PtrToNode
typedef struct Node *PtrToNode;

// 定义结构体Node, 它包含2个成员：int型的key, 指向node类型的指针Next
struct Node {
    int Key;
    PtrToNode Next;
};

// 给PtrToNode起别名为List
typedef PtrToNode List;
```

要求算法额外空间复杂度为O(1)，时间复杂度为O(n)。

#### 裁判测试程序样例：

```c++
#include <stdio.h>
#include <stdlib.h>

typedef struct Node *PtrToNode;
struct Node {
    int Key;
    PtrToNode Next;
};
typedef PtrToNode List;

List Read(); /* 细节在此不表 */
void Print( List L ); /* 细节在此不表；空链表将输出NULL */

// 构造函数 声明
void ListUnion( List L1, List L2 );

int main()
{
    List L1, L2;
    L1 = Read();
    L2 = Read();
    ListUnion(L1, L2);
    Print(L1);
    Print(L2);
    return 0;
}

/* 你的代码将被嵌在这里 */
```

#### 输入样例：

```
4
13 10 9 5
4
15 10 5 2
```

#### 输出样例：

```
15 13 10 9 5 2
10 5
```

#### 代码：

```c++
// 合并两个链表 并集降序并删除重复元素 重复元素单独形成一个降序链表
void ListUnion(List L1,List L2){
    
    // a,b为遍历两个链表的指针 tempa、tempb是a、b的前一个元素, 用于插入
    List a,b,tempa,tempb;
    a = L1->Next;
    b = L2->Next;
    tempa = L1;
    tempb = L2;
    
    // 只要ab不为空
    while(a!=NULL&&b!=NULL){
        // 当b较大时
        if(a->Key < b->Key){
            // 将b取下 
            tempb->Next = b->Next;
            
            // 将b插到a的前面
            tempa->Next = b;
            b->Next = a;
            
            // 更新b为tempb的后一个元素 a向后移动一位
            b = tempb ->Next;
            tempa = tempa->Next;
        }
        // 当ab相等时
        else if(a->Key == b->Key){
            // a、b、tmpa、tmpb均向后移动一位 重复元素在两个链表中各存在一次
            tempa = tempa->Next;
            a = a->Next;
            tempb = tempb->Next;
            b = b->Next;
        }
        // 如果a比较大时
        else if(a->Key > b->Key){
            // a向后移动
            a = a->Next;
            tempa = tempa->Next;
        }
    }
    
    if(b != NULL){
        //cout << tempa->data <<endl;
        // 将b接到tmpa的后面 tmpb后面为空
        tempa->Next = b;
        tempb ->Next = NULL;
    }
}
```



<br>

<br>

<br>

# 补充

### 从源文件到可执行文件

```
预处理 -> 编译 -> 汇编 -> 链接
```

- 预处理：根据预处理命令将源代码转换为新的 c 程序，不过通常以 i 为扩展名
- 编译：将得到的 i 文件翻译成汇编代码，通常以 s 为扩展名
- 汇编：将汇编文件翻译为机器指令，并打包成可重定位目标程序的 o 文件
- 链接：将引用的其它 o 文件加到汇编后的 o 文件中，处理后得到最终的可执行文件
  





#### 关于字符串和转义字符

```c
void main(){
	char a, b, c, *p;
	a=’\’; b=’\xbc’; c=’\0xab’; p=”\0127”;
	printf(“%c %c %c %c\n”, a, b, c, *p);
}
```

编译时出现错误，以下叙述中正确的是（）
A. 程序中只有a=’\’;语句不正确
B. b=’\xbc’;语句不正确
C. p=”\0127”;语句不正确
D. a=’\’;和c=’\0xab’;语句都不正确

答案是D，不知道为什么，于是又去复习了一下c语言的转义字符。常用的c语言转义字符如下表所示：

这道题里a= ‘\’是不正确的，必须是a= ‘\\’,因为\标识转义字符，如果是 ‘\’,那\’就会被当做转义字符，字符会缺一个单引号，语法错误，需要后面再加个单引号，如a= ‘\”，但这样得到的字符就是\’了。关于b和c，转义字符\h、\hh、\hhh斜杠后面的是1~3位八进制数，该转义字符为ASCII码等于该值的字符；转义字符\xh、\xhh的\x后面的是1~2位十六进制数，该转义字符为ASCII码等于该值的字符。所以b= ‘\xbc’是对的，相当于b=0xbc，也即十进制的-68，虽然这个数对于ASCII字符没有意义，但作为char的数值是没有错的（char是带符号八位整形，取值范围为-128~127）；c= ‘\0xab’是错的，没有这个表示方法。p=“\0127”是对的，这里\012是一个转义字符，相当于八进制的12，查ASCII表可知是换行符\n，所以p相当于p= “\n7”。所以a和c变量是错的，答案选D。







<hr>




二、

编译运行下列程序的输出结果是： **无法确定**

```c
#include <stdio.h>

void fun(int a, int b, int c) { c = a * b; }

int main() {
    int c;
    fun(4, 3, c);
    printf("c: %d", c);
    return 0;
}
```

- 解释：因为c没有初始化。

    实参只是将值传递给形参，形参在调用函数内的变化，并不会影响到原来的实参，这两个是独立存在的

    main函数中，c并没有赋值，是个不确定的值，这个值传递到func的第三个参数上，不管在func里面怎么变化，main函数里面的c都不会改变，还是个不确定的值



<br>



三、

```c
int x = 1;

int f(int x) {
    static int k = 0;
    return (k++) + x;
}

int main() {
    int k;
    for (k = 1; k < 4; k++) printf("%d#", f(k + x));
}
```

输出结果为：2#4#6#

```c
static int a;
int b;

void func(void){
	static int c;
	int d;
}
```

上面程序中，a与b都是全局变量，二者的区别是，b可以被别的文件使用，a只能在本文件中使用，这是static对全局变量的作用。

c和d的区别是，d是一个自动变量，func函数执行完后，d会自动被释放。但c却不会被释放，下一次调用func函数时，c的值会保留上次的值继续使用。



四、

```c
struct dent {
    int no;
    int *m;
};
int a = 1, b = 2, c = 3;
struct dent s[3] = {{101, &a}, {102, &b}, {103, &c}};

int main()
{   struct dent *p = s;
    ……
}
```

则以下表达式中值为 2 的是：(2分)	**D**

1. `*(*(p+1))->m`
2. `*(p++)->m`
3. `(*p).m+1`
4. `*(++p)->m`

A选项为2的地址，B选项为1，C选项为1的地址+1，D选项为正确选项。



五、

设有以下语句，则变量 `c` 的十进制数是： `char a = 3, b = 6, c; c = a^b<<4-2;`(2分)

1. 27
2. 20
3. 78
4. 97

运算符优先级应该是减大于左移大于异或，a是0011，b是0110，b先左移两位变为011000，再和a异或得到11011，也就是27



六、


以下给出四种算法的时间复杂度，如果当 N=100 时它们对应的运行时间依次是：A 算法 100 毫秒、B 算法 30 毫秒、C 算法 20 毫秒、D 算法 10 毫秒，则当 N=200 时，哪种算法最快？ **B**

1. ```
    A. O(N)
    B. O(N^2)
    C. O(N^3)
    D. O(N^4)
    ```

    - A：原来O(N) = KN = 100	现在O(2N) = K * 2N = 200
    - B：原来O(N^2) = k * n^2 = 30 现在O(2N) = k * (2n)^2 =  120
    - C：原来O(N^3) = k * n^3 = 20 现在O(2N) = k * (2n)^3 = 160
    - D：原来O(N^4) = k * n^4 = 10 现在O(2N) = k * (2n)^4 = 160



七、

运行下列程序，得到文件的内容是： **in_C_is_fun** 

```c
void fun(char fname, char st) {
    FILE *myfile;
    int i;
    myfile = fopen(fname, "w" );
    for (i=0; i<strlen; i++)
        fputc(st[i], myfile);
    fclose(myfile);
}

int main() {
    fun("f", "Programming");
    fun("f_", "in_C_is_fun");
    return 0;
}
```

- w 打开只写文件，若文件存在则文件长度清为0，故文件中只有第二个字符串





C语言中，全局变量和局部静态变量是存储在静态存储区的，他们在分配的时候都被系统默认初始化为0；而局部自动变量是在栈上分配内存的，如果不对它们进行初始化，那么他们可能是任意的随机值。


（1）main函数内的变量不是全局变量，而是局部变量。

（2）只不过它的生命周期和全局变量一样长而已。

（3）全局变量一定是定义在函数外部的。





c++中 . 和 -> 主要是用法上的不同。
1、A.B 则A为对象或者结构体；
2、A->B 则A为指针，->是成员提取。A->B是提取A中的成员B，A只能是指向类、结构、联合的指针；

```
p->val 和 (*p).val使用上等价
```

