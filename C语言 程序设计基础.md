



参考书籍：C语言程序设计 何钦铭（第三版）

<hr>

# 一、 数据表达与组织

## 1.1 常量、变量、运算、表达式

**C语言标识符** ：由 `字母` 、 `数字` 、 `下划线` 组成，且必须是 `字母` 或 `下划线` 开头，且 **区分大小写**

标识符分为：

- **关键字（保留字）** ： 如 `typedef` 、`int` 、 `if` 、 `return` 等
- **用户定义的标识符**



<br>



**C语言中的数据类型：**

- **整型** 
    - 有符号整形 (`int` 、 `short` 、 `long` 、 `long long` )：int占4字节
    - 无符号整形 ( `unsigned int` 等)
- **字符型 (char)** ：表示单个字符，用单引号占一字节，本质是该字符表示的ASCII值（整型）
    - 'A'：65 ， 'a'：97
- **浮点型(实型)**
    - 单精度float
    - 双精度double    `%08.3f\n` 表示显示8位数（包含小数点）， 不足8位用0填充，且保留3位小数
- **布尔(_Bool)**
    - 1表示 `true` ，0表示 `false` 



<br>



**关于字符串：**

c语言中没有字符串类型，但有字符串的概念，同时 `string.h` 中也有着相关操作字符串的函数

字符串（常量）是以NULL结尾的0个或多个字符组成的序列，常量所以不可修改，并用双引号，例如 `"Hello!"` ， `"123abc\n"`

字符串结尾默认有个空字符 `'\0'`

字符串常量与指针关系密切

因为字符串常量的值，实际上表示的是 **存储这些字符的内存空间的地址** ，更准确地说是 **字符串常量中第 1 个字符的地址** ，而 **不是这些字符本身**

因此，在 C 语言中不能直接进行字符串赋值，常通过声明一个指向 char 类型的指针并将其初始化为一个字符串常量的方式来访问一个字符串：

```c
char *msg = "Hello World!";
 
// 上面的语句也可以拆分成下面两句
char *msg;
msg = "Hello World!";　　　　// 这句话看起来像是字符串复制，其实不是，只是涉及到指针操作

// 可以进行遍历
while(*msg != '\0'){
	printf("%c ",*msg++);
}
```



<br>



**关于字符数组：**

在 C 语言中，除了字符串常量外， **其他所有字符串都必须存储于字符数组或动态分配的内存中**

定义和普通数组一样，只不过存放的元素是char类型的

```c
// 声明并初始化一个字符数组 下面两个效果一样
char str[] = {'H','e','l','l','o'};    
char str[] = "Hello World!";

// 可以进行修改 将小写变大写
for(int i = 0; i < strlen(str); i++){
	if( str[i] <= 'z' && str[i] >= 'a')
		str[i] = str[i] - 32;
}
```



<br>



**字符串常量和字符数组的区别：**

- 字符串常量是一个字符数组，但是内容和长度在初始化时就已经固定了， **不可更改** ；可以通过一个指向字符串常量第一个元素的指针来访问该字符串常量；

- 字符数组是一个用于存放字符的数组，字符数组的值是 **可以更改的** 



<br>



**常量** ：程序运行中不能被改变的量

**变量** ：程序运行中可以被改变的量

```c
// 声明一个变量
类型说明符 变量名A, 变量名B = B的初始值;
```



<br>



**运算：**

- **算术运算** ：`+` 、 `-` 、`*` 、`/（整除）` 、`%（只用于int）`（当双目运算符两边类型不同时，会自动进行类型转换）
- **赋值运算** ：`=` 左边必须是变量，右边计算完后会自动转化为左边的类型，再赋予左边
- **关系运算** ： `>` 、`<` 、 `!=` 等
- **位运算** ： 按位取反，按位与，左移右移等（操作数的移位不改变原操作数的值，除非通过赋值）

**（重要）运算符的优先级（数字越小越优先）和结合性（没写就是左到右，操作数两边的优先级相同时，先与左边的运算符结合）：**

1. 括号 `[]` 和 `<>` 、成员选择 `.` 和 `->` 
2.  `逻辑非!`     **右到左**
3. `单目-` ， `按位取反~` ， `自增++ 自减--` ，`指针取值*` ， `取地址&` ， `强制类型转换` ， `sizeof`    **右到左**
4. 乘，除，取模
5. 加，减
6. 左移<< ， 右移>> 
7. 大于，小于，大于等于，小于等于
8. 等于，不等于
9. 按位与&
10. 按位异或^
11. 按位或|
12. 逻辑与&&
13. 逻辑或||
14. 三目条件运算符 `?:`    **右到左**
15. 赋值运算符一类，包括 `=` ，`+=` 等    **右到左**
16. `,` 运算符

总结：

- 同一优先级的运算符，运算次序由结合方向所决定

- 简单记： `！> 算术运算符 > 关系运算符 > && > || > 赋值运算符`

- 成员选择比++高， `*p++` 先*再++

    



<br>



**表达式：** 由运算符和操作数组成的有意义的运算式子

- 常量表达式：a

- 算术表达式：a+b

- 赋值表达式：a=1    **计算右边的值，再赋予左边，左边的值就是整个赋值表达式的值**

- 关系表达式：a>b    **关系表达式的值是整型，1或者0**

- 逻辑表达式：a&&b    **可以是任何类型，非0表示真，0表示假**

- 条件表达式：`a?b:c`

- 复合表达式

- 逗号表达式：`a,b` 按顺序执行，整个逗号表达式中每个语句都会被计算到，整个逗号表达式的值为最后一个表达式的值。作为条件的时候，非0真，0假

    ```c
    //执行时a的值会自增1，b的值也会自增1，最终将b自增后的值赋给变量z
    //此时z的值为5，也就是最终整个逗号表达式的结果。
    int a = 3,b = 4,z = 0;
    z = ++a,++b;	
    ```

    





<br>



## 1.2 一维和二维数组，字符数组和字符串

**一维数组：**

```c
类型名 数组名[数组长度];

// 初始化
int a[10] = {1, 2};	// a[0]的值是1, a[1]的值是2，其余元素默认是0
```

- 数组名是地址，是存放数组内存空间的首地址
- 数组长度是常量，下标从0~n-1
- 数组中的元素在内存中连续存放，数组名和下标可以唯一确定数组元素



<br>



**二维数组：**

```c
类型名 数组名[行长度][列长度];

// 初始化 按行
int a[4][3] = {{1, 2, 3}, {}, {4, 5}};
int a[4][3] = {1, 2, 3, 0, 0, 0, 4, 5};
```

- 二维数组在内存汇总按行/列优先存放
- 如果初始化时对全部元素赋值，或者分行赋值时列出了全部行，可以忽略行长度
- **一维长度可忽略，二维长度必须有**



<br>

1. **错误** a[1][2]是一行两列

    ```c
    int a[1][2] = {{1},{3}};
    ```

    

2. 可以在赋值语句中通过赋值运算符=对字符数组整体赋值 **错误**

    在赋值语句中通过赋值运算符"="对字符数组整体赋值，则就需要用到字符数组名，而对字符数组名进行操作时其会退化为常量指针，而进行赋值时左值必须是可以修改的变量。

    **初始化可以，赋值不行**

3. 



<br>



### 计算多维数组中 aij 的地址

**当数组 `a[m][n]` 按行优先**

```
Loc(a[i][j]) = 首地址 + [已经满多少行 + 当前列数] * 每个元素多少字节
```

**当数组 `a[m][n]` 按列优先**

```
Loc(a[i][j]) = 首地址 + [已经满多少列 + 当前行数] * 每个元素多少字节
```



例题：

设 `A[5][4][3]` 在内存中首地址为1000，每个元素占2个存储单元，按行优先存储，求`A[4][3][2]`的首地址（A的下标从0开始）

```
三维数组看做层号、行号、列号
那么A[4][3][2]中4、3、2分别对应这个点的层数、行号、列号
4说明之前有4层是满的(0123) 也就是4*(4*3) =  48
3说明之前有3行是满的(012) 也就是3*(3) = 9
2说明之前有2个元素 也就是2
位置为4*(4*3)+3*3+2=59

因此A[4][3][2]的首地址就是1000 + 59*2 = 1118
```



<br>



### 二维数组: 指针、下标表示的关系

**对于 `a[2][3]`**

- 数组名a也是指向第一个数组元素且二维数组的数组元素在计算机内的内存存放也是连续的
- 和一维不一样的是：a+1的值不是 `&a[0][1]` ，而是`&a[1][0]` (即a+1跳过的不是一个单元，而是一行单元，a+1指向的是第二行第一个元素的地址）
- **若要表示 `a[i][j]` 的地址，应该是 `*(a+i)+j`**

但是注意一、二维数组名一样，虽然a+1的值等于第二行第一个元素的地址，但是使用指针运算符引用 `*(a+1)` 得到值依然只是一个地址。

有说明语句`int a[4][5];`，则`a[2]+3`表示__。 (2分)

`a`数组行下标为`2`、列下标为`3`的元素的地址

```
*((*a+3)+1)  就是*(*a+4) 就是a[0][4]
*(*(a+2)+3)  a[2][3]
```



<br>



**对于指向二维数组的指针**

如果建立一个这样的指针 `int *p = a` 

后面再补充



<br>



**字符数组**

```c
char str[10];
char t[6] = {'H', 'I'};	// 没赋初始值的元素为0，也就是'\0'
```

- 如果初始化时对所有元素都赋初值，可以忽略数组长度



<br>



### putchar() 和 getchar()

- putchr()：
    - 输出单个字符，可以填数字，也可以填字符，返回值都是字符
- getchar()：
    - 不带任何参数，用于读取用户从键盘输入的单个字符



```c
// 返回结果 A65
sum = putchar('A');
printf("%d",sum);

int ch = getchar();	//实际变量ch中放的是读到的那个字符的ASCII码值
putchar(ch);	//putchar接收到一个参数（ASCII码值），输出相对应的字符
```



<br>



### sizeof() 和 strlen()

- sizeof：
    - 计算的是分配的数组所 **占的内存空间的大小** ，不受里面存储的内容影响
    - sizeof算 **字符长度** ， `\n` 、 `\123 、 `\0 都算， **可以看做长度加1** 
- strlen：
    - **获取字符的个数， 字符串长度**
    - 遇到 `\0` 停止
    - 要求参数是char*类型（string类型可以用 `.size()` ）

几个重要的知识点： 

- sizeof(数组名)，表示整个数组的大小
- strlen从首元素开始数，没有字符串结束标志 `\0` 就是随机值

```c
char str[5] = "abc";
int a = sizeof(str);    // 5
int b = strlen(str);    // 3

char str[] = "abc";
int a = sizeof(str);    // 4
int b = strlen(str);    // 3

char str[]="abc\ndef\0g\123h";
int a = sizeof(str);    // 12
int b = strlen(str);    // 7
```



<br>



## 习题

1. 已知 ‘9’ 的 ASCII 码是 57，‘a’ 的 ASCII 码是 97，‘A’ 的 ASCII 码是 65。

    以下程序结果是：`a5`

    ```c
    int main() {
        char a[40] = "a\065\0b";
        puts(a);
        return 0;
    }
    ```

    八进制转义为 `\0hh` ， 即为\0后面为两个数

    十六进制转义格式为 `\xhhh` ，即为\0后面为三个数

    `\065` 发生了转义， 变为了八进制数 `53` ，也就是ASCII值为53的字符，也就是 `5` , 后面的 `\0` 为结束符

    

2. 设有如下函数，期望返回一个字符串:

    ```
    char *p(int n)
    {   ______________________________
        return s+n;
    }
    ```

    该函数内的下划线处填入以下哪个选项时，将 **不能** 正确得到函数返回的字符串？(2分)	**B**

    ```c
    A. char *s="abcdefghij";
    B. char s[]="abcdefghij";
    C. static char s[]="abcdefghij";
    D. char *s; s=(char *)malloc(10); strcpy(s,"abc123");
    ```

    解释：

    

3. 若有 `char w; int x; float y; double z;` 则表达式 `w*x+z-y` 值的数据类型为 **double**
    计算表达式时，首先要将各个变量强制转化为最高的存储类型

    

4. 以下选项中属于非线性结构的是 A

    ```
    A.广义表
    B.队列
    C.优先队列
    D.栈
    ```

    广义表(Lists，又称列表)是一种非连续性的数据结构，是线性表的一种推广。即广义表中放松对表元素的原子限制，**容许它们具有其自身结构**

    

5. 【878，2019】有以下定义，正确的是  **s1的长度要大于s2的长度**

    ```
    char s1[ ]="abcdefg";
    char s2[ ]={'a', 'b', 'c', 'd', 'e', 'f', 'g'};
    ```

    - s1是字符串的定义，结尾有个 `\0`
    - s2是字符数组的定义，没有 `\0` ，因此s2的长度比s1要少1

    

6. 





<br>



**字符串**

字符串常量是用 **双引号** 括起来的字符序列，以 `'\0'` 为结束符

字符串"happy"由6个字符组成，有效长度是5

C语言中字符串作为特殊的一维字符数组来处理

```c
// 以下等价
char s[3] = {'g', '0', '\0'};
char s[3] = {"go"};
char s[3] = "go";

char s[80];	// 80不影响, 因为遇到\0就结束了
s[0] = 'g';
s[1] = 'o';
s[2] = '\0';
```



<br>



```c
char *s = "name";
cout << *(s+1);	// 结果是a
cout << s+1; 	// 结果是ame
```



<br>



## 1.3 指针与数组，结构与数组

#### 指针（重中之重）

C语言中，专门用来存放变量地址的变量称为 **指针**

```c
类型名 *指针变量名

// p是一个指针，指向一个int型的变量a（或者说p存放的是int型变量a的地址） a就是一个int型的变量
int a = 3;
int* p = &a;

// 这是一样的
int a = 3;
int* p;
p = &a;

// 如果a是数组名, 因为数组名就是地址
int* p = a;

// 就是n
*&n;
```

- 指针本身也是变量，只不过他存放的内容是别人的地址
- `*` 除了定义指针，还用于访问指针指向的变量，也称为 **间接访问运算符**
- *p：a的值
- p：a的地址



<br>



**取地址符合间接访问运算**

```c
int a = 3, *p;
p = &a;     // p指向a的地址 *p的值和a的值是一样的
printf("a=%d, *p=%d\n", a, *p); // 3 3

*p = 10;    // 修改p所指向的变量的值, 相当于对a赋值
printf("a=%d, *p=%d\n", a, *p); // 10 10

a = 5;
// *p = *p++或者++*p也是一样的效果
(*p)++; // 将指针所指向的变量+1
printf("a=%d, *p=%d\n", a, *p); // 6 6

// 而*p++的效果是*(p++)，先取*p的值,再将p的值(也就是a的地址)+1, 导致p不再指向a
*p++;
printf("a=%d, *p=%d\n", a, *p); // 6 114514
```



<br>



**赋值运算**

只能将一个指针的值（也就是地址）赋给另一个相同类型的指针

```c
int a = 3, *p1, *p2;
p1 = &a;
    
p2 = p1;	// 此时p1和p2都指向a, *p2、*p1、a访问同一个内存单元

// 赋初值
int *p = 1000; // 错误
int *p = 0;	// 正确 此处0就是ASCII的NULL 定义了一个空指针
```



<br>



#### 指针、数组和地址间的关系

数组名本身就是地址，也就是指针的值，在访问内存方面，数组和指针几乎是相同的

数组名可以看做特殊的固定地址

```c
int a[10], *p;

p = a + 1; // 正确
a = a + 1; // 错误
```

- a+i就是距数组a的基地址的第i个偏移
- ***(a+i) 和 a[i] 等价**
- **数组和指针的本质区别** ：数组a是指针常量，不是指针变量
- 如果p指向int型的变量，则p+1就指向int型的下一个变量的内存地址，p的值加上1个int类型的长度（2字节）
- 如果p和q都是指向数组元素的指针，p-q是int型的值，表示在p和q之间的元素个数
- 指针的算术运算中：只有链各个相同类型的指针相减和指针加上或减去一个整数是合法的，其他都是非法的



<br>



#### 二维数组和指针的转换

```c
 int a[2][3]={1,2,3,4,5,6};
 int *p=a;	// p是int*型的 指向数组a的首地址
  // 此时*(p+3)和a[1][0]等价 都是4


```

- 此时和一维数组的情况类似



<br>



```c
int a[2][3]={1,2,3,4,5,6};
int (*p)[3]=a;	// p是一个指向int数组的指针
```

- p是指针，*p是指针取出的值，此处是一个 int数组。也就是说 `*p` 和 `a[0]` 是一致的
- `*(p+1)` 也是一个 int 类型的数组, *(p+1) 和 a[1] 是一致的
- `*(p+1)+1`，相当于把指向 `a[1]` 的指针移动一位，表示 `a[1][1]` 的地址
- 再取值 `*(*(p+1)+1)` 就是 `a[1][1]` 的值

也就是说：

- `p` 和 `p+1` 类型相同是 **指向数组** 的指针
- `*p` 和 `*(p+1) ` 类型相同是 **指向元素** 的指针
- `**p` 和 `**(p+1)`以及 `*(*(p+1)+1) `类型相同是取出的 **数值**
- 二维数组取值公式： ` *(*(p+m)+n)` 相当于 `a[m][n]` ， 此处a是二维数组，p是数组指针，m行号，n列号



<br>



#### 数组名作为函数的参数

```c
// 传参时，传的其实是a的基地址，加上[]其实是习惯
int add(int a[], int n){	// int a[]等价于int *a
    int ans = 0;
    for(int i = 0; i < n; ++i)
        ans += a[i];
    return ans;
}	

// 调用
add(b, 10);		// 从b[0]加到b[9]
add(&b[7], k-7);	//从b[7]加到b[k-1] 
add(b+7, 2*k)	// 从b[7]加到b[2*k+6] 
```

- 第二个，从b[7]开始，注意项数数不变的
- 第三个，将b的地址偏移7，也就是从b[7]开始，b[7]传参变成a，函数执行过程中所有地址都会偏移7



<br>



## 1.4 指针与结构，单向链表

#### 结构

自己定义的，包含的分量称为结构成员，可以是任意类型的

```c
// 结构体数组的初始化
struct sturdent{
    int num;
    char name[10];
}sturdents[50];


```

- 结构的定义以分号结束，结构的定义整体是一条语句
- 在嵌套定义时，必须先定义成员的结构类型
- 关键字struct和结构名必须一起用，整体为数据类型名
- 只有相同结构类型的变量直接才可以直接赋值
- 结构体内可以定义函数



<br>



**结构体数组**

对数组元素的成员的引用 数组下标和结构成员操作符组合实现

```c++
sturdents[2].num
```



<br>



#### 结构指针

结构指针就是指向结构类型变量的指针

```c++
struct stundent s1 = {27, "chen"}, *p;
p = &s1;

// 访问成员的两种方式 等价的
(*p).num = 28;	// *p表示p指向的结构变量, 点的优先级高于*, 因此需要括号
p->num = 28;
```



<br>



**结构指针作为函数参数**

```c++
// 定义
int update_score(struct student *p, int n){
    ...
}

// 使用
update_score(sturdents, n);
```

- 将结构数组的数组名（也就是结构体指针）传给形参p，在函数中就可以通过结构指针p对结构数组中的数据进行间接访问操作了
- 优点：使用结构指针作为参数只需要传一个地址，就可以操作结构体数组



<br>



#### 单向链表（单链表）

下面是一个定义的例子

```c++
// 定义一个Node结构体
struct Node{
    int key;
    struct Node *next;
};
// 创建一个Node结点
struct Node *p;
p = (struct Node*)malloc(sizeof(struct Node));


// 可以typedef起别名
typedef struct Node{
    int key;
    node *next;
    
    // 结构体内定义一个初始化的函数
    node(int _val) : key(_val), next(NULL) {}
}node;
// 创建一个Node结点
node* p = new LinkNode(x);
```

- next分量又是该结构类型的指针，称为结构的递归定义（c++在递归定义时可以不加struct）
- 链表相对于数组的有点：不用事先定义大小，可以动态分配，可以方便的插入新元素



<br>



**单链表的基本操作**

1. 遍历

    ```c++
    for(p = l; p; p = p->next){
        ...
    }
    ```

    - 结点在内存中不连续，因此不能用p++



2. 插入结点

    ```c++
    // 将p插到q的后面
    p->next = q->next;
    q->next = p;
    ```

    

3. 删除结点

    ```c++
    // 删除p后面的结点q
    p->next = q->next;
    free(q);
    ```

    

<br>



## 习题

1. 【878，2019】对于以下变量的定义，正确的赋值是： **D**

    ```c
    int *p[3], a[3];
    
    A. p = a
    B. *p = a[0]
    C. p = &a[0]
    D. p[0] = &a[0]	// 和p[0] = a; 一个效果
    E. a = p[0];
    ```

    - p是指针数组名，p的类型是 `int**` 
    - `p[0]` 是指针，也就是 `int*` 类型的
    -  `&a[0]` 在此处等同于 `a` ，都是数组首个元素的地址

    

2. 下面程序的输出是 **12**

    ```c
    int a[12] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, *p[4];
    for(int i = 0; i < 4; i++ )
    	p[i] = &a[i * 3];
    printf("%d\n", p[3][2]);
    ```

    p是指针数组，数组中的每个元素都是指针

    可以看到p[0] = &a[0]，p[1] = &a[3]， p[2] = &a[6]，p[3] = &a[9]

    而 `p[3][2]` 根据数组和指针的转换，相当于 `*(p[3] + 2)` 也就是p[3]的值（a[9]的地址）往后移动2个单位（a[11]）的值

    ```c
    p[2]相当于*(p+2)
    p[3][2]相当于*(p[3] + 2)
    ```

     

3. 下列程序的输出结果是 **efgh**

    ```c
    char *fun(char *t){
    	char *p = t;
    	return (p+strlen(t)/2);
    }
    
    int main(){
    	char *str = "abcdefgh";
    	str = fun(str);
    	puts(str);
    }
    ```

    strlen(t)/2就是t的长度除以2

    相当于返回p+4，指针向后移动4位，就是从下标4开始后面的值

    ```c
    char str[] = "abcdefgh";	// str字符数组, 内容可以修改
    
    char *str = "abcdefgh";		// str是指向字符串的指针, 内容不可修改
    ```

    

4. 设有如下定义的链表，则值为7的表达式是 **(++p)->n**

    ```c
    struct st{
    	int n;
    	struct st *next;
    }a[3] = {5, &a[1], 7, &a[2], 9, NULL}, *p=&a;	// 这里应该是*p=a比较合理
    ```

    

    p指向的是a数组的首地址，++p就是第二个元素，第二个元素的n成员就是7

    ```c
    a       表示数组元素的首地址，同时也可做为数组的指针使用	a+1 为数组的第二个元素地址
    &a      表示整个数组的首地址							 &a+1 跳过整个数组后的地址
    &a[0]   表示数组第一个元素的地址						&a[0]+1 同a+1
    ```

    

5. 【878，2016】如果有变量定义`char **pp[10];`，那么下面说法正确的是：**D**

    ```c
    A. pp是指向字符指针的指针变量
    B. pp是字符指针
    C. pp[4]是字符指针
    D. pp是数组名
    ```

    - 首先看元素：数组中的元素类型是char**，也就是指针的指针，那么pp是指向元素的指针，他是3重指针，也是数组名

    

6. 程序的输出结果是： **cb**

    ```c
    char *s="adc";
        while (*s++) // 遍历字符串 优先级是*大于自增 且在判定完再加1
            if (*s)     // 只要*s不为空
                putchar(*s-1);  // 输出前一个字符
    ```

    

7. 程序的输出结果是：**IRST**

    ```c
    char *c[3]={"FIRST", "SECOND", "THIRD"};
    printf("%s", *c+1);	// 等同于c[0]+1
    
    // 效果类似于
    char *a = "FIRST";
    printf("%s", a+1);
    ```

    

8. 【878，2017】对于下列数组 `a`, 能正确输出 1~6 某个值的语句是 **A**

    ```C
    int a[3][2]={1,2,3,4,5,6};
    
    A. printf("%d", *(a[1]+3));	// a[1][3]的值
    B. printf("%d", a[1]+3);	// a[1][3]的地址
    C. printf("%d", *(a[3]+1));	// a[3][1]的值, 但是非法
    D. printf("%d", a[3]+1);
    ```

    

9. 不正确的赋值或赋初值方法是： **C**

    ```c
    char str[]="string";
    char str[7]={'s', 't', 'r', 'i', 'n', 'g'};
    char str[10]; str="string";
    char str[7]={'s', 't', 'r', 'i', 'n', 'g', '\0'};
    ```

    - `char str[10];` 是定义了一个含有十个元素的数组，而且这十个元素在内存中是以连续的存储单元存放的。其中str是该数组的数组名字，也是数组的首地址，数组名是一个指针常量，不能被赋值，不能进行自增自减

    

10. 对于下面定义，赋值不正确的是 **D**

    ```c
    struct Student {
         long num;
         char name[20];
    } st1, st2={101,"Tom"}, *p=&st1;
    
    A. st1=st2
    B. *p=st2
    C. p->num=st2.num
    D. p->name=st2.name
    ```

    - 字符数组不能直接赋值字符数组

    

11. 【878，2018】对于数组 `int a[3][2]`，哪个能正确访问到 `a` 中的元素？**A**

    ```c
    A. a[-1][3]
    B. a[2][2]
    C. a[3][1]
    D. a[0][-1]
    ```
    
    - 对于二维数组 `int a[M][N]` 来说，`arr[i][j]` 的地址是 `(*arr) + i*N + j`，其值就再加一个*
    - 因此A选项 `a[-1][3]` 相当于a+1的值，也就是第二个元素的值，也就是相当于 `a[0][1]`

    

12. 【878，2018】如果 `int a[5], *p = &a[2];`，那么哪个与 `p[1]` 等价？ **a[3]**

        p指向的是a[2]的地址，故p[1]为*p+1, 指向a[3]



13. 对于定义 `char *s, str[10]= "hello";`，下面哪个语句是正确的？ **C**

    ```c
    A. strcpy(s, str);
    B. str=s;
    C. printf("%s", str+2);
    D. s=str[0];
    ```

14. 下列程序的输出结果为：`abc:9:3`

    ```c
    char s[]="abc\0d123";
    printf("%s:%d:%d", s, sizeof(s), strlen(s));
    ```
    
     - 字符串以 `\0` 作为结尾
     - sizeof为总空间+1，也就是8+1=9，`\0` 占一个空间
     - strlen遇到 `\0` 停止



15. 【878，2018】对于下面的定义，++p->c的值是多少？ `'b'`

    ```c
    struct S{
         int n;
         char c;
    } st[5] = {1,'A',2,'a',3,'B',4,'b'}, *p = st+1;
    ```

    - 取成员的优先级比++高，p就是st[1]，取成员的结果是 `'a'` ，再++得到结果

    

16. 下列表达式哪个是无意义的？ `A`

    ```c
     A. "Flower"-"Flow"
     B. 'F'-'A'
     C. "Flower"+2
     D. 'A'+3/2
    ```
    
     -  B是字符之前的距离，结果是5
     - C是字符串从2开始的内容，结果是字符串ower
     - D是字符A的ASCII值+1，也就是65+1，结果是66
    
    

17. 对于以下定义，表达式 `(x+y)%2+a/(int)b` 的值为 **4** （但我感觉是4.6）
          

       ```
       int x=3, y=2;
       float a=3.6, b=1.8;
       ```

       - 自动类型转换和强制类型转换

       

18. 对于变量定义 `int *p[3], a[3];` 正确的赋值是 **D**

       ```c++
       A. p = a
       b. *p = a[0]
       C. p = &a[0]
       D. p[0] = &a[0]
       ```

       - p是一维数组，p是指针的指针，p[0]是一维指针，a是一维指针，a[0]是数
       - D写成p[0] = a也是对的
       - *p就是p[0]

       

19. 经过如下定义时的初始化 `int a[ ][3] = { {1,4}, {3,2}, {4,5,6}, {0} }`，`a[2][1]` 的值是 **5**

20. 【878，2019】以下定义中，哪个p不是指针？ **都是指针**

       ```c++
       char **p; // 指向指向char的指针
       char (*p)[10]; // 代表了一个指针，指向一个大小为10的字符数组 注意和下面这个的区别
       char *p[6];	// 代表了一个大小为10的数组，数组的每个元素都是一个字符指针。p是char** 类型的，p中的每个元素是char*类型的
       ```

       

21. 【878，2020】设变量定义为 `char a[20], *p=a;` 下面赋值语句中正确的是 **A**

      ```c++
      A. p= "Zhejiang";
      B. a= "Zhejiang";
      C. *p= "Zhejiang";
      D. a[20]= "Zhejiang";
      ```

      - D选项，a[20]是一个字符怎么能容纳一个字符串？况且a[20]也是不存在的！
      - B选项，a是指针，但是它已经指向在堆栈中分配的20个字符空间，现在这个情况a又指向数据区中的"Zhejiang"常量，这里的指针a出现混乱，不允许！
      - C选项，*p等号右边的得是一个地址

      

22. 【878，2020】设有变量定义： `int a[2][3]={0,1,2,3,4,5};` 下面 4 个表达式中最大的是：**B**

      ```c++
      A. a[1][2]-2
      B. a[0][3]+1
      C. a[2][-3]
      D. *(*a+3)
      ```

      - `A[i][j]` 在此处就是第 `i*3+j + 1` 个元素
      - `A[1][2]` 的值是5
      - `A[0][3]` 的值是3
      - `A[2][-3]` 的值是3
      - `*(*a+3)` 就是 `A[0][3]`

    

23. 设 `x`、`y`、`z` 均为 `int` 类型，若表达式 `x||y&&z` 的值为 1，则

      ```
      A. 若 x 为 0，则 y 和 z 必均为 1
      B. 若 y 和 z 均为 1，则 x 必为 0
      C. x、y、z 必都为 1
      D. 若 x 为 0，则 y 和 z 均不为 0
      ```

      - 由于xyz都是int类型的，所以只要两个不为0的数与或者或都是1

          

24. 【878.2016】则以下表达式中值为 2 的是：	**D**

    ```c
    struct dent {
        int no;
        int *m;
    };
    int a = 1, b = 2, c = 3;
    struct dent s[3] = {{101, &a}, {102, &b}, {103, &c}};
    
    int main()
    {   struct dent *p = s;
        ……
    }
    
    A. *(*(p+1))->m
    B. *(p++)->m
    C. (*p).m+1
    D. *(++p)->m
    ```

    - A选项为2的地址，B选项为1，C选项为1的地址+1，D选项为正确选项。
    
    
    
25. 【878，2017】 `while (!x&&!y)` 语句中的表达式 `!x&&!y` 等价于 **B**

    ```C
    A. x=0 && y=0
    B. !(x || y)
    C. !( x==0 || y==0)
    D. !( x==0 && y==0)
    ```

    - 只有x和y都是0，表达式的值才为1，只有B满足

    

26. 








<br>

<br>

<br>



# 二、语句和流程控制

## 2.1分支控制（if、switch）

**if的一般形式：**

```c
if(表达式1) 语句1;
else if(表达式2) 语句2;
else 语句三;
```



<br>



**switch的一般形式：**

```c
switch(表达式){
    case 常量表达式1: 
        语句1; 
        break;
        
    ...
        
    case 常量表达式n:
        语句n;
        break;
    default:
        表达式n+1;
        break;
}
```

- 先求解switch()中的表达式
- 根据表达式的结果，找到对应的case，执行对应的语句段。 **并继续执行下面所有的代码（包括default），直到遇到break或者语句结束**
- 如果case都不满足，就执行default，default可以省略，表示什么都不做



<br>







<br>



## 2.2 循环控制(for、while、do-while)

**for的一般形式：**



```c
// 从哪儿开始；到哪儿结束；步子迈多大
for(表达式1; 表达式2; 表达式3){
	循环体
}
```

- for中根据 **循环控制变量** 来控制循环的执行
- 表达式1： 定义循环变量，只会在循环之前执行1次
- 表达式2： 判断循环变量的值，为真继续循环，为假循环结束
- 表达式3： 步长表达式，设置对循环控制变量的改变。每次循环体执行结束，就会执行表达式3



<br>



```c
int i;
for(i = 0; i < 10; i++ );  // for后面的;表示的是空语句
    
// 在i=9结束之后, 会执行i++使得i变为10, 下次循环时, 不满足表达式2，循环终止
// 最后i的值为10
printf("%d", i);   
```



<br>



最后i的值为：`5`

```c
for(i=1; i++ <4; );
```



<br>

 



**while的一般形式：**

```c
while(表达式){
	循环体
}
```

- 当表达式值为真时，就执行循环里面的语句
- 当表达式为假时，终止循环执行while的下一条语句



<br>



最后k和s的值为：`-1 6`

```
int k = 4, s = 0;
while(k--)s+=k;
```





<br>



**do-while的一般形式：**

```c
do{
	循环体
}while(表达式);
```

- 先执行循环体一次，然后判断条件
- 因此 **至少会执行一次循环体**



## 习题

1. 执行下列程序后，s的值是 **6**

    ```c
    int i=5, s=0; 
    
    while(i--)
    	if (i%2) continue; 	// 奇数会continue
    	else s+=i;	// 偶数会加到s上
    ```

    

2. 语句 `for(int i=0,j=10; i=j=10; i++,j--);` 的执行次数是 无限次

    ```
    因为中间的句子是赋值语句, 恒为1
    ```

    

3. 【878，2020】执行完以下语句段后，s的值是

    ```c++
    int main( )
    {   
        int i=5, s=0;
        do{
            if (i%2) 
                continue; // 跳过下面的 直接来到while的判断
            else
                s+=i;
            
        } while (--i);
        
        return 0;
    }
    
    /*
    i=5,s=0
    i=4,s=4
    i=3
    i=2,s=6
    i=1,s=6
    */
    ```

    

4. 【878，2016】程序输出结果是： `6#4#`

    ```c
    int k=2, s=0; 
    switch(k) { 
        case 2: 
            s++; 
            k++;
        case 1: 
            s++; 
        case 3: 
            s+=1; 
        switch(s){ 
            case 2: 
                s+=2; 
                break; 
            default: 
                k++; 
                break; 
        } 
        default: 
            s+=3; 
    } 
    
    printf("%d#%d#", s, k);
    ```

    - 找到对应的case之后会执行下面的所有代码，包括default

5. 



<br>

<br>

<br>



# 三、程序结构和函数

## 3.1 C程序结构

主函数main() + 若干函数

- 一个C语言程序总是从main函数开始执行的，而不论main函数在整个程序中的位置如何
- 可以用 `//` 对程序进行注释，注释不被编译，不生成目标程序，不影响程序运行结果
  





<br>



## 3.2 函数的定义、参数传递和调用

函数是一个完成特定工作的独立程序模块，分为：

- 库函数
- 自定义函数



一般形式：

```c
函数类型 函数名(形参表){
	函数实现过程
}
```

- 返回值要和函数类型一致
- 每个形参前的类型都必须写



<br>



### 形参和实参

- 从主函数开始，遇到某个函数，就暂停主函数，先执行对应的函数
- 进行函数调用时，实参的 **值** 会依次传给形参，这就是参数传递
- 形参必须是变量，为了接受从实参传来的值
- 实参可以是常量、变量、表达式，当实参是变量时，和对应的形参是两个不同的变量
- **参数传递是值传递，单向的，形参的值在函数中的改变不会影响实参**
- return 只能返回一个值



<br>



## 3.3 函数的递归调用



<br>



## 3.4 变量的存储类别、作用域、全局变量、局部变量

### 局部变量和全局变量

定义在函数内部的变量称为 **局部变量** ，有效作用范围只在函数内部，形参是局部变量

定义在main()中的变量也是局部变量，作用域只在main()中

定义在函数外的称为 **全局变量** ， 有效作用范围是从定义到程序的结束，对范围内的所有函数都起作用

当局部变量和全局变量重名时，在局部以局部变量为主



<br>



### 变量生存周期和静态局部变量

主函数中的所有局部变量一开始就分配存储单元

其他函数只有函数被调用时，形参和局部变量才分配对应的存储单元，函数调用结束，存储单元会被系统回收，因此局部变量也称为自动变量

变量从定义开始分配存储单元到运行结束存储单元被回收，整个过程称为 **变量生存周期**

对于全局变量，生存周期为整个程序执行周期



<br>



**静态局部变量**

存放在静态存储区，不会像普通局部变量因为函数调用结束而被系统回收， **生存周期会持续到程序结束，再次调用还能用上次的值**

```c
static int i = 1;
```

- **自动变量** 如果没有赋初值，在存储单元中是 **随机值**
- **静态变量** 如果没有赋初值，将 **自动赋值0** 
- **赋初值只在第一次调用时起作用，之后每次都用上次的值**
- **静态局部变量的生存周期从函数的第一次调用开始，贯穿整个程序**
- 但作用域仍然只在对应函数中，主函数中也不能用



<br>



```c
static int a;
int b;

void func(void){
	static int c;
	int d;
}
```

- a与b都是全局变量，二者的区别是，b可以被别的文件使用，a只能在本文件中使用，这是static对全局变量的作用。
- c和d的区别是，d是一个自动变量，func函数执行完后，d会自动被释放。但c却不会被释放，下一次调用func函数时，c的值会保留上次的值继续使用。



<br>



### 变量的存储类别

保存变量的数据区分为：

- 动态存储区（堆栈）：保存自动变量（局部变量）
- 静态存储区：保存全局变量、静态局部变量



<br>



## 习题

1. 在C语言中，若对函数类型没有显式说明，则函数的隐含类型为 **int** （不是void哦）

2. 实参和其对应的形参各占用独立的存储单元 **正确**

3. 【878，2016】编译运行下列程序的输出结果是： **无法确定**

    ```c
    #include <stdio.h>
    
    void fun(int a, int b, int c) { c = a * b; }
    
    int main() {
        int c;
        fun(4, 3, c);
        printf("c: %d", c);
        return 0;
    }
    ```

    - 由于函数并未改变c的值，所以c为初始值，然而c为局部变量且没有赋初值，故无法确定

        实参只是将值传递给形参，形参在调用函数内的变化，并不会影响到原来的实参，这两个是独立存在的

        

4. 程序输出结果是：**2#4#6#**

    ```c
    int x = 1;
    
    int f(int x) {
        static int k = 0;
        return (k++) + x;
    }
    
    int main() {
        int k;
        for (k = 1; k < 4; k++) printf("%d#", f(k + x));
    }
    ```

5. 如果所有的变量按照下面的程序进行定义和声明，那么在main()函数中所有可用的变量为 ==a,b,z==

    ```c
    void fun(int x)
    {
        static int y;
        ...
        return;
    }
    int z;
    void main( )
    {
        int a,b;
        fun(a);
        ...
    }
    ```

    - 编译器一般不对普通局部变量进行初始化，也就是说它的值在初始时是不确定的，除非对其显式赋值，普通局部变量存储于进程栈空间，使用完毕会立即释放。

    - 静态局部变量使用static修饰符定义，即使在声明时未赋初值，编译器也会把它初始化为0。且静态局部变量存储于进程的全局数据区，即使函数返回，它的值也会保持不变。

        

6. 【878 2018】调用下列函数 `f(f(3))` 的返回值是什么？ **0**

    ```c++
    int f(int k) {
        int s;
        static int a = 1;
        for (s = 0; a < k; a++) { s = s + a; }
        return s;
    }
    ```

    - a是局部静态变量，在f(3)结束的时候a的值变为3， 且f(3)=3。 
    - `f(f(3))` 执行到for的时候，s赋值为0，a的值为3，不小于k，跳出循环，故返回的值为0。

    

7. 【878，2022】下列程序的输出结果是： **1 5**

    ```c++
    void fun(int n, int *m)
    {   n=n+2;
        *m += n;
    }
    int main( )
    {   int a=1,b=2;
        fun(a,&b);
        printf("%d %d",a,b);
        return 0;
    }
    ```

    - a 传进去的是值，函数不会影响到a
    - b 传进去的是地址，所以会受到影响

    

8. 【878，2020】对于以下变量定义，赋值错误的是： **B**

    ```c++
    struct node {
        char s[10];
        int i;
    } p[5];
    char *t= "abc";
    
    A. p[0].i=2;
    B. (p+2)->s=t;
    C. (*p).i=*(t+1)-'a';
    D. *(p->s)= *(t+1);
    ```

    - B 选项 不能把 `char*` 类型赋值给字符数组
    - C选项 t+1是 `bc` ，`*(t+1)` 是b

9. 



<br>

<br>

<br>

# 四、输入/输出和文件

## 4.1 标准输入和输出

### 4.1.1 标准输入 scanf()

引入头文件：

```c
#include<stdio.h>
```

一般格式为：

```c
scanf(格式控制字符串, 参数1, …… , 参数n)
    
例如：
scanf("x=%lf", &x);

scanf("%d%d", &n, &m); // 可以正确读入20 30，因为scanf在处理输入时，如果格式占位符不是%c，它就会将空白字符（空格符、制表符和换行符）都视为一次输入的终止标记
scanf("%c %c", &n, &m);// 如果是%c,需要加上空格，否则m会变为空格
```

- 格式控制字符串用 **双引号** ， 包含：
    - `格式控制说明(格式占位符)` ：例如 `int型` 需要 `%d` ， `float` 需要 `%f` ， `double` 需要 `%lf`
    - `普通字符` ：原样输入的字符，一般会尽量避免在scanf中使用普通字符
- 参数是变量的地址
- 参数和格式控制说明要一一对应







<br>



### 4.1.2 标准输出 printf()

引入头文件：

```c
#include<stdio.h>
```

一般格式为：

```c
printf(格式控制字符串, 参数1, …… ，参数n)
    
// 输出浮点型时的格式控制
%+a.bf    
%-a.blf
a:输出数据的宽度 不足补空格
b:小数位
+: 右对齐 不写默认是右对齐
-: 左对齐
printf("%3.3lf\n",1.3345);    //有效小数位数是 3 位 最后一位5没有打印,四舍五入往前进了一位
```

- 格式控制字符串用 **双引号** ， 包含：
    - `格式控制说明(格式占位符)` ：例如 `int型` 需要 `%d` ， `float` 和 `double` 需要 `%f`
    - `普通字符` ：原样输出的字符
- 参数是输出的数据，可以是常量、变量、表达式
- 参数和格式控制说明要一一对应



<br>

格式占位符：

|   **于有符号整型**   | **%d or %i** |
| :------------------: | :----------: |
|     **用于字符**     |    **%c**    |
|    用于无符号整型    |      %u      |
|   **用于单浮点数**   | **%f or %F** |
| **用于双精度浮点数** |   **%lf**    |
|    **用于字符串**    |    **%s**    |





<br>



| 常用的转义字符 |                   效果                   |
| :------------: | :--------------------------------------: |
|       \n       |                   换行                   |
|       \r       | 换行(回到当前行首)，判断按键是否是回车键 |
|       \t       |                 水平制表                 |



<br>



## 4.2 文本文件和二进制文件

### 4.2.1 文件的定义：

C语言中的文件类似于数组、结构等，是一种数据组织方式，是C语言程序处理的对象

C语言把文件看作数据流，并按一维方式组织存储（像磁带）



<br>



### 4.2.2 文本文件、二进制文件

**文本文件/字符文件** ： 以字符ASCII码值进行存储和编码的文件，内容就是字符

**二进制文件** ： 存储二进制数据的文件

C语言的 **目标文件（.o）** 和 **可执行文件（.exe）** 是二进制文件，包含给计算机识别的机器代码





<br>



## 4.3 文件打开、关闭、读写和定位

**文件缓冲系统：**

进行文件操作时，在程序和文件之间的一个内存缓冲区，来进行数据交换

缓冲文件系统中，系统 **自动分配** 一块文件缓冲区（内存单元），且数据处理只考虑文件缓冲区即可，内存和磁盘之间是操作系统的事



<br>



### 4.3.1 文件处理步骤

1. 定义文件指针  `FILE *fp` ，fp为指向文件结构的指针， 注意不能用fp++和*fp
2. 打开文件：文件指针指向磁盘文件缓冲区
3. 文件处理：对文件进行读写操作
4. 关闭文件



<br>



### 4.3.2 打开文件

打开文件操作由 `fopen()` 实现

```c
FILE fp;
fp = fopen("文件名", "文件打开方式");
```

- 成功，返回包含文件缓冲区等信息的FILE结构地址，赋予文件指针fp；否则（文件不存在，被其他软件打开，本身错误等等）返回一个NULL的FILE指针
- 文件名是字符串，指明文件的路径：默认是当前的文件夹，否则就是完整路径，例如 `c:\\abc.txt` 此处用了转义符

关于文件打开方式：

（下面是 **文本文件（ASCII）** 的文件打开方式）：

| 使用方式 |           含义           |
| :------: | :----------------------: |
|    r     |   打开文件， **只读**    |
|    w     | **新建** 文件， **只写** |
|    a     |   打开文件， **追加**    |
|    r+    |     打开文件，读/写      |
|    w+    |   **新建** 文件，读/写   |
|    a+    |   打开文件，读/写/追加   |

- 只有w是新建，其他都是打开
- +代表功能的增加
- 对应的换成二进制文件只要加个b，例如从 `w+` 变为 `wb+`
- 文件打开的实质是将磁盘文件和文件缓冲区对应
- 打开之后，对文件的读写操作只需要使用文件指针，且已经打开，操作方式就已经被确定，关闭之前都不能改变
- 可以同时打开多个文件，但不允许同一个文件在关闭之前被再次打开



<br>



例如打开文件abc.txt，只读的两种方式：

```c
fp = fopen("abc.txt", "r");	// 字符串常量代表文件

char *p = "abc.txt";	// 字符指针表示文件
fp = fopen(p, "r");

if((fp = fopen("abc.txt", "r")) == NULL){
   	文件出错;
    exit(0);	//exit(0) 是系统标准函数, 关闭所有打开的文件并终止程序。0表示正常结束, 其他表示非正常结束
}
```



<br>



### 4.3.3 关闭文件

数据写入文件，首先是先写到文件缓冲区，缓冲区满（512B）才真正写到磁盘

在写满之前程序中止，这部分数据就会丢失

文件关闭可以强制使缓冲区中的数据写入磁盘

关闭文件操作由 `fclose()` 实现

```c
fclose(文件指针);
```

- 返回值为整数，0表示正常关闭
- fclose() 将释文件缓冲区单元和FILE结构，解除文件和文件指针的关联
- 文件使用结束完要及时关闭文件





<br>



### 4.3.4 文件读写

标准库stdio.h中的一些函数

#### 字符方式文件读写 fgetc() 和 fputc()

对于文本文件，操作的数据都是ASCII字符文本



```c
ch = fgetc(fp);	// 从fp指向的文件中读一个字符到ch, 只要成功, fp就会自动移到下一个位置。 失败, 返回EOF 	补充：类似getchar(), 从键盘中读一个字符
fputc(ch, fp);	// 将ch写到fp所指的文件		成功返回ch, 失败返回EOF(值为-1) 补充：类似putchar(), 将ch显示在屏幕
```

- 文件缓冲区中的位置会随着fgetc()和fputc()而自动改变
- 实际上是对文件缓冲区进行读写
- 不要在程序中用fp++来改变文件缓冲区的位置，fp指向的是文件结构

实现从A文件写数据到B文件：

```c
#include<stdio.h>
#include<stdlib.h>

int main(void){
    FILE *fp1, *fp2;
    char ch;
    
    // 打开两个文件
    if((fp1 = fopen("a.txt", "r")) == NULL){
        printf("a错误！\n");
        exit(0);
    }
    if((fp2 = fopen("b.txt", "w")) == NULL){
        printf("b错误！\n");
        exit(0);
    }
    
    // 进行复制 
    while(!feof(fp1)){  // feof()判断是否到了文件尾
        ch = fgetc(fp1);
        if(ch != EOF)   // 因为feof()在末尾之后再一个循环才会变成true 例如最后一个字符是'a'，此时feof是false，再读一次返回EOF，feof才是true
            fputc(ch, fp2);
    }
    
    // 关闭文件
    if(fclose(fp1)){
        printf("a 无法关闭！\n");
        exit(0);
    }
    if(fclose(fp2)){
        printf("b 无法关闭！\n");
        exit(0);
    }
    
    return 0;
}
```



<br>



#### 字符串方式文件读写  fgets() 和 fputs()

读写文件时以字符串为单位

```c
fgets(s, n, fp);	// 从文本中读字符串
```

- s不能为字符串常量
- fp是文件指针
- n为读取的字符个数，最多读取n-1个字符，并存入s指向的内存地址开始的n-1个连续单元
- 到指定个数、遇到换行符、EOF时，自动加上一个 `\0` ，换行符会保留，EOF不会保留
- 成功返回字符串；否则返回空指针，此时s中的内容不确定



```c
fputs(s, fp); 	// 向文件中写入字符串
```

- s可以是字符数组名、字符型指针变量、字符串常量
- fp是文件指针
- 写入的时候字符串结束符 `\0` 不写入
- 成功返回最后一个字符；否则返回EOF



<br>



#### 格式化方式读写 fscanf() 和 fprintf()



```c
fscanf(文件指针, 格式化字符串, 输入表);
fprintf(文件指针, 格式化字符串, 输入表);

// 从文件中读入整形n, 浮点型x
fp = fopen("a.txt", "r");
fscanf(fp, "%d%f", &n, &x);

// 将n和x写入文件
fp = fopen("b.txt", "w");
fprintf(fp, "%d%f", n, x);
```

- 类似于scanf()和printf()
- 格式转化计算机会自动完成



<br>



#### 其他相关函数：

和文件定位相关的函数：

- `rewind()` ：回到文件的首地址 `rewind(FILE *fp);`
- `fseek() ` ：控制文件读写指针移动 `fseek(fp, offset, from);` from可取012，表示开头、现在和末尾
- `ftell()` ：获取当前文件读写指针的位置，即相对开头的位移量 `ftell(文件指针)`

检测文件指针状态的函数：

- `feof()` ： 判断是否读到了EOF，成功返回true
- `ferror()`
- `clearerr()`



<br>

## 习题

1. `printf("%d %d %d", NULL, '\0', EOF);` 的结果是： **0 0 -1** 

2. 如果二进制文件a.dat已经存在，现在要求写入全新数据，应该用 **"wb"** 方式

3. `FILE *fp;` ，则文件指针指向的是 **文件类型结构**

4. 缓冲文件系统的文件缓冲区位于 **内存缓冲区中**

5. 文件的三大特征： **名称、大小、类型**

6. `fopen()` 的返回值是 **指向文件缓冲区的首地址的文件结构类型指针**

7. 缓冲文件系统和非缓冲文件系统的区别： **系统是否为文件自动分配一块文件缓冲区（内存单元）**

8. 【878，2017】想以可读可写而不清空原文件的方式打开 `D` 盘中的一个文件 `abc.txt`，下面函数调用正确的是 **C**

    ```c
    A. fopen("D:\user\abc.txt","r+");
    B. fopen("D:\user\abc.txt","w+");
    C. fopen("D:\\user\\abc.txt","r+");
    D. fopen("D:\\user\\abc.txt","w+");
    ```

    

9. 以下`scanf`函数调用语句中不正确的是 **C**

    ```c
    struct pupil {
        char name[20];
        int age;
        int sex;
    } pup[5], *p=pup;
    
    scanf("%s", pup[0].name);
    scanf("%d", &pup[0].age);
    scanf("%d", p->age);	// 这个不是地址
    scanf("%d", &(p->sex));
    ```

    

10. 【878，2018】如果函数 `void fcopy( FILE *t, FILE *s )` 将文件 `s` 的内容拷贝到 `t`，则下面哪个是正确的调用？ `C`

    ```c
    FILE *fp1, *fp2;
    fp1 = fopen("D:\\user\\abc1.txt","r");
    fp2 = fopen("D:\\user\\abc2.txt","w");
    
    A. fcopy( fp1, fp2 );
    B. fcopy( stdin, stdout );
    C. fcopy( fp2, stdin );
    D. fcopy( stdin, fp1 );
    ```

    - 这题的意思就是看看哪个不报错
    - fcopy() 将第二个参数的内容拷贝到第一个参数
    - stdin是读，stdout是写，fp1是只读，fp2是新建，写
    - 只有c是不报错的

    

11. 【878，2016】运行下列程序，得到文件的内容是： **in_C_is_fun** 

     ```c
     void fun(char fname, char st) {
         FILE *myfile;
         int i;
         myfile = fopen(fname, "w" );
         for (i=0; i<strlen; i++)
             fputc(st[i], myfile);
         fclose(myfile);
     }
     
     int main() {
         fun("f", "Programming");
         fun("f_", "in_C_is_fun");
         return 0;
     }
     ```

     - w 打开只写文件，若文件存在则文件长度清为0，故文件中只有第二个字符串




<br>

<br>

<br>



# 五、编译预处理和命令行参数

## 5.1 宏定义和宏函数

### 5.1.1 宏定义

通常用于符号常量定义，实现简单函数，或者为了书写更方便

目的为了增强代码可读性，减少函数调用成本

**格式：**

```c
#define 宏名 宏定义字符串
```

- 在编译预处理中起作用（编译时，将代码中有宏名的地方用宏定义字符串来 **替换** ），不是真正的C语句
- 末尾没有分号（有分号的话分号也会替换进去）
- 宏名中间无空格，宏定义字符串随意，回车符作为结尾
- 如果一行太长，可以用 `\` 下一行继续写

**可宏嵌套定义：**

```
#define PI 3.14
#define S PI*r*r
```



<br>



### 5.1.2 宏函数

```c
#define MAX(a, b) a>b?a:b

x = MAX(x, y);
```

**和函数调用的区别：**

- 宏定义在编译预处理时完成，进行替换。**宏定义只做替换，不做计算**
- 函数调用在程序执行时才进行，并且传参，**计算表达式后返回**

**为了防止出错，要加括号：**

```c
// y会变成x+y*x+y 出错
#define SQR(x) x*x
y = SQR(x+y);

// 替换时括号会保留 这样就不会出错
# define SQR(x) (x) * (x)
```

**配合逗号表达式：**

```c
// 这样会出错
#define ALERT(str)  {putchar('\a');puts(str);}
// 替换为 if(n) {putchar('\a');puts(str);};
if(1) ALERT("hhh");

// 正确 整个逗号表达式中每个语句都会被计算到 
#define ALERT(str)  {putchar('\a'),puts(str);}
// 替换为 if(n) {putchar('\a'),puts(str);};
if(1) ALERT("hhh");
```



<br>



## 5.2 typedef关键字

typedef 的作用是起别名

```c
// 一般用法
typedef  旧名字  新名字;

// 例子
typedef int *INTEGER;
INTEGER a, *b;	// 等价于int* a,*b;
```

- 相当于给int*起了个别名叫INTEGER
- a是 `int` 型的指针变量
- b是指向「指向整型的指针」的指针



<br>



和数组一起用

```c
typedef int arr[5];
arr a;	//定义了一个有5个int型变量的数组a
```



<br>



### 5.2.1 和宏定义的区别

- typedef 仅限于为数据类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名
- 宏定义只是简单的字符串替换，由预处理器来处理
- 而 typedef 是在编译阶段由编译器处理，它并不是简单的字符串替换，而给原有的数据类型起一个新的名字，将它作为一种新的数据类型
  



<br>



## 5.3 命令行参数和使用

C语言源程序经过编译和连接生成可执行文件（可执行程序/可执行命令）后，可以在操作系统环境中用命令方式来执行

例如用命令 `test` 来执行当前目录下的 `text.exe`

而一个命令行中可以包括命令和参数（也可没用，用空格分开），这些参数就是 **命令行参数**

```
命令 参数1 参数2 
```

C语言中主函数可以有两个参数：

```c
int main(int argc, char *argv[]){}
```

- argc 为命令行参数（包括命令）的个数
- argv 以字符串常量方式存每个命令行参数：argv[0]是命令，argv[1]是参数1……
- argv实际上还是指针，指向数组的首地址，*argv是命令行参数，可以修改 `*(argv++)`
- 可以取其他名字，这两个是约定俗成



<br>



例如：

echo.c:

```c++
#include<stdio.h>

int main(int argc, char *argv[]){
	// 打印命令行参数
	for(int k = 1; k < argc; k++)
		printf("%s", argv[k]);
		
	return 0;
}
```

命令行下输入：

```
echo are you ok？
```

输出

```
are you ok？
```



<br>



## 5.4 习题

1. 如果有宏定义 `#define MUL(x,y) (x*y);` 那么表达式 `MUL(MUL(2+3,6),4+2)-7` 的值是：**75**

    宏展开时，从内到外

    ```c
    MUL(MUL(2+3,6),4+2)-7
    MUL((2+3*6),4+2)-7
    ((2+3*6)*4+2)-7
    ```

1. 【878，2016】假如下面程序的源程序文件名是 `echo.c`，编译链接后的可执行程序文件名是 `echo.exe`，那么执行命令 `echo How Are You?` 的输出是：**oe?d!**

    ```c
    #include <stdio.h>
    int main(int argc, char *argv[])
    {   int k, i=0;
        static char s[10]= "Good!";
        for(k = 1; k <argc; k++)  s[i++] = *(argv[k]+k);
        printf("%s", s); 	
        return 0;
    }
    ```

    - argv[1]的内容是 `How` ， argv[2]的内容是`Are` ， argv[3] 的内容是 `You?`
    - `*(argv[k]+k)` 就是 `argv[k][k]`





<br>



<hr>


<br>

<br>

<br>



# 六、基本算法设计与程序实现

## 简单排序算法

### 插入排序



<br>



### 选择排序



<br>



### 冒泡排序



<br>



## 二分查找

指针和数组的应用

```c
#include <stdio.h>

int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int x, m;

// 二分查找 用循环实现了递归
int Bsearch(int *p, int n, int x){
    int low = 0, high = n - 1, mid;
    
    while(low <= high){
        mid = (low + high) / 2;
        if(x == p[mid])
            break;
        else if(x < p[mid])
            high = mid - 1;
        else 
            low = mid+1;
    }
    if(low <= high) return mid;
    return -1;
}

int main(){
    printf("查找X:");
    scanf("%d", &x);
    
    m = Bsearch(a, 10, x);
    
    if(m >= 0)
        printf("Index is %d\n", m);
    else 
        printf("Not Found\n");
        
    return 0;
}
```

- a作为实参，在函数中就能访问a数组中的元素，并且也能改变单元的内容
- 可以采用数组形式，也可采用指针形式，例如 `p[mid]` 等价于 `*(p+mid)`





<br>

<br>

<br>



# 填空题

## 2016

### 4-4 先序中序建树

给定一棵树的先序遍历序列为 { 1 2 3 4 6 7 5 }，后序遍历序列为 { 2 6 7 4 5 3 1 }，建树

![2016_4-4](assets/C语言 程序设计基础/2016_4-4.PNG)



<br>



### 5-1 约瑟夫环问题

一群猴子要选新猴王。新猴王的选择方法是：让 `n` 只候选猴子围成一圈，从某位置起顺序编号为 1~`n` 号。从第 1 号开始报数（从 1 到 4），凡报到 4 的猴子即退出圈子，接着又从紧邻的下一只猴子开始同样的报数。如此不断循环，最后剩下的一只猴子就选为猴王。以下程序采用单循环链表模拟了这个过程，`KingOfMonkey` 函数返回猴王编号。请在空缺处填上正确的代码。

```c++
// 约瑟夫环问题

typedef struct node    
{   int number; /*猴子的编号*/
    struct node *next; /*指向下一只猴子的指针*/
} linklist;

int steps = 4; /*报数到这个定数(正整数)，确定下一只出局的猴子*/
linklist *CreateCircle(int n); /*创建有n个编号的无头结点单循环链表*/
int KingOfMonkey(int n, linklist *head);

int main()
{   linklist *head;
    int n;
    scanf("%d",&n); 
    if (n>0){    
        head = CreateCircle(n);
        printf("%d\n", KingOfMonkey(n,head));
    }
    return 0;
}

linklist *DeleteNext(linklist *p) /* 删除单循环链表的p所指的下一个结点 */
{   linklist *s;
    if ( p && p->next!=p ) { 
        s=p->next;	// 此处为空
        p->next = s->next;
        free(s);  
        return p->next;
    }else if (p){             
        free(p);  
        return NULL;
    }else 
        return NULL;
}

int KingOfMonkey(int n,linklist *head)
{   linklist *p = head;
    int i, j;       
    for(j=1; j<=n-1; j++){   
        for(i=2; i<steps; i++)  p=p->next;
        p=DeleteNext(p);	// 此处为空
    }   
    return p->number;	// 此处为空
} 
```





<br>



### 5-2 有理数加法

假如有理数类型定义如下：

```c++
typedef struct
{   int n; /*numerator,分子，允许是负数*/
    int d; /*denominator，分母，大于0；且n和d没有大于1的公因子*/
} RATIONAL;
```

下面是两个有理数的加法函数 `AddR()` 以及相关的另两个函数代码，请对程序填空。

```c++
unsigned int gcd( int x, int y); /*求最大公因子*/
RATIONAL Simplify(RATIONAL a); /*有理数约简，如6/9约简为2/3*/
RATIONAL AddR(RATIONAL a, RATIONAL b) /*有理数相加，如：1/2+2/3=7/6 */
{   RATIONAL t;
    a = Simplify(a); b = Simplify(b);
    t.n = a.n*b.d+b.n*a.d;	// 此处为空
    t.d = a.d * b.d;
    return Simplify(t);
}
RATIONAL Simplify(RATIONAL a) /*化简有理数*/
{   RATIONAL t;
    int divisor = gcd(a.n, a.d);	// 此处为空
    t.n =  a.n / divisor;
    t.d = a.d / divisor;
    return t;
}
unsigned int gcd(int x, int y) /*y>0; 求|x|与y的最大公因子*/
{   int r;
    if ( x < 0 ) x = -x;
    while(1)
    {   r = x % y;
        if (r == 0) return y;
        x = y;
        y = r;	// 此处为空
    }
}
```



<br>



### 5-3 拓扑排序

下列代码的功能是对一个给定的图`G`执行拓扑排序，其中`TopNum[]`从 1 开始记录拓扑序。请完成程序填空。

```c++
void Topsort( Graph G )
{   Queue Q;
    Vertex V, W;
    NodePtr ptr;
    int counter = 0;
    Q = CreateEmptyQueue(G->NumV); /*初始化队列*/
    for ( V=0; V<G->NumV; V++ )
        if ( Indegree[V] == 0 ) /*Indegree[V]记录V的入度*/
            Enqueue(V, Q);
    while ( !IsEmpty(Q) ){
        V = Dequeue( Q );
         TopNum[V] = ++counter;	// 此处为空
        for ( ptr=G->List[V]; ptr; ptr=ptr->Next) {
            W = ptr->Vert;
            if (--Indegree[w]==0)	// 此处为空
                Enqueue(W, Q);
        }
    }
    if (count<G->NumV)	// 此处为空
        printf("错误：此图存在环\n");
    DisposeQueue(Q);
}
```



<br>



## 2017

### 5-2 堆排序

```c++
#define leftchild(i) ( 2*(i)+1 )
void PercDown( ElementType A[], int i, int N )
{  int child;
   ElementType Tmp;
   for ( Tmp = A[i]; leftchild(i) < N; i = child ) {
      child = leftchild(i);
      if ((child+1 <= N-1)&&(A[child]<A[child + 1]))	// 此处为空
         child ++;
      if (Tmp < A[child])	// 此处为空
          A[i] = A[child];
      else  break;
   }
   A[i] = Tmp;
}

void Heapsort( ElementType A[ ], int N ) 
{  int i; 
   for ( i = N/2; i >= 0; i -- ) 
        PercDown( A, i, N ); 
   for ( i = N-1; i > 0; i -- ) { 
        Swap( &A[0], &A[i] ); 
       	PercDown( A, 0, i ); 	// 此处为空
   } 
}
```



<br>



## 2018

4-3 运行下列程序后输出是： `u#ience#5#4`

```c++
int main()
{  
    char *s[] = {"computer", "science"}, *p; 
    char format[] = "%d#%c"; 
    p = *s;
    printf("%c#", (++p)[3]);  
    printf("%s#", s[1]+2);
    printf(format, strlen(format), "123456"[2]+1);
    return 0;
}
```

- `(++p)[3])` 相当于 `*((++p)+3)` 相当于 `*(p+4)` 相当于 `p[4]`
- s[1]就是science，再加2你懂的
- `"123456"[2]+1`  就是字符3加1，就是字符4



<br>



4-4 下列程序的输出结果是：`First:12 Next:13`

```c++
#define  s(x,y)  x^=y^=x^=y     // x^=y^=x^=y的作用是将x和y的值对调
int  func( int a[], int n )
{   int i, j, k = 0;
    for ( i = 0; i < n; i++ ) 
        for ( j = i+1; j < n; j++ ) 
            if ( a[i] > a[j] ) k++; 
    return k;
}

int main()
{   int a[7] = {5,1,7,4,3,6,2};
    printf("First:%d ", func(a,7));
    s(a[1],a[2]);
    printf("Next:%d", func(a,7));
    return 0; 
}
```

- s()的作用是将a[1]和a[2]的值交换



<br>



### 4-5 后序中序建树

给定一棵二叉树的后序遍历结果是 { 6, 5, 8, 2, 9, 1, 7, 3, 4 }，中序遍历结果是 { 6, 5, 1, 2, 8, 9, 4, 3, 7 }。



<br>



### 5-1 删除链表中的逆序结点

有关链表结构定义：

```c
typedef struct node {
    int data;
    struct node *next;
} NodeT;
```

下列函数将不带头结点的单链表中的逆序结点删除，形成从小到大的非递减序列。例如：若当前链表 h 为 3->5->2->6->1->4->7，将删除逆序结点 2、1、4，形成链表 3->5->6->7。

```c++
NodeT *order( NodeT *h )
{  
    NodeT *p, *t;

    p = h;
    while ( p!=NULL ) {
        t = p->next;
        if (t == NULL) break;	// 此处为空
        else if ( p->data <= t->data ) 
             p = p->next;	// 此处为空
        else {
            p->next = t->next;	// 此处为空
            free(t);
        }
    }
    return h;
}
```



<br>



### 5-2 求任意两点的最短路径

函数 `SP` 用于求给定图 `Graph` 中任意两点间的最短路径。二维数组 `Graph->G` 存放的是图的邻接矩阵，`D` 用于保存最短路径长度（即 `D[i][j]` 保存顶点 `i` 到 `j` 之间的最短路径长度），`Path` 用于存储路径。图类型 `MGraph` 的定义如下：

```c
typedef struct GNode *PtrToGNode;
struct GNode{
	int Nv;  /* 顶点数 */
	int Ne;  /* 边数   */
	WeightType G[MaxVertexNum][MaxVertexNum]; /* 邻接矩阵 */
};
typedef PtrToGNode MGraph; /* 以邻接矩阵存储的图类型 */
```

请完成程序填空。

```c
void SP( MGraph Graph, WeightType D[][MaxVertexNum], Vertex Path[][MaxVertexNum] )
{
    Vertex i, j, k;

    for ( i=0; i<Graph->Nv; i++ )
        for( j=0; j<Graph->Nv; j++ ) {
            D[i][j] = Graph->G[i][j];
            Path[i][j] = -1;
        }
    for( k=0; k<Graph->Nv; k++ )
        for( i=0; i<Graph->Nv; i++ )
            for( j=0; j<Graph->Nv; j++ )
                if(D[i][k]+D[k][j]<D[i][j]) {	// 此处为空
                    D[i][j] = D[i][k]+D[k][j]; 	// 此处为空
                    Path[i][j] = k;	// 此处为空
                }
}
```



<br>



## 2019

4-1 下列程序的输出结果是 `  -5, -12,  -7`

```c
void sub(int x, int y, int *z)
{   *z =*z + y - x;   }

int main()
{   int a=0, b=0, c=0;
    sub(10, 5, &a);
    sub(7, a, &b);
    sub(a, b, &c);
    printf("%4d,%4d,%4d\n", a, b, c);
}
```

- 注意%4d哦



<br>



### 4-3 完全二叉搜索树

给定一系列数字 { 78，29，13，43，51，37，64，97，85 }，请将其填入一棵完全二叉树，且使得该树同时为二叉搜索树。

![完全二叉搜索树](assets/C语言 程序设计基础/完全二叉搜索树.PNG)



<br>



### 4-4 Dijkstra 

使用Dijkstra算法求下图从顶点1到其他顶点的最短路径

![2019_填空题_4-4 Dij](assets/C语言 程序设计基础/2019_填空题_4-4 Dij.JPG)

手动模拟：

![6F23DA3E683F172BC3C6251E389C5C24](assets/C语言 程序设计基础/6F23DA3E683F172BC3C6251E389C5C24.png)



顶点序列：2、4、3、6、5、7；

距离序列：5、7、11、17、18、20。



<br>



### 5-1 字符串加密

对一段明文（字符串）`s`，采用换位法进行加密的方法是：密钥是一个 `k`（≤20）个元素的整数数组，所有元素是正整数 1 至 `k` 的一个任意排列，根据密钥，以 `k` 个字符为一段，依次替换为秘钥指定的顺序。比如：如果秘钥数组为 `[1,3,2,5,4]`，明文 `abcdefghij01234`，则将明文分为 `abcde`、`fghij`、`01234` 三段，将每段按照 `12345` 顺序转换为秘钥指定的顺序 `13254`, 因此得到的三段密文为：`acbed`、`fhgji`、`02143`。因此，最后所得密文为：`acbedfhgji02143`。

（1）下列函数 `move()` 将字符串 `s` 从 `start` 位置开始的 `k` 个字符转换为秘钥 `key` 规定的顺序,请将函数空缺部分填写完整。

```c++
void move(char s[],int start, int k, int *key)
{   char t[20];
    int i;
    for (i=0;i<k;i++)    t[i]= s[start+ key[i] -1];	// 此处为空
    for (i=0;i<k;i++)    s[start+i]=t[i];	// 此处为空
} 
```

（2）下列函数 `cryptoText()` 调用上述 `move()` 函数，将字符串 `s` 按照每 `k` 个字符一段进行换位加密，采用的秘钥为 `key`，假设 `s` 的长度是 `k` 的倍数。同时在 `main()` 中通过具体的 `s` 和 `key` 调用 `cryptoText()` 进行测试。请正确填写其中两次函数调用的调用参数。

```c++
void cryptoText(char *s, int k, int *key)
{   int i;
    for (i=0;s[i]!='\0';i=i+k)
        move(s,i,k,key);	// 此处为空
}

int main()
{   char s[]="abcdefghijk0123";
    int key[]={1,3,2,5,4};
    cryptoText(s,5,key);    	// 此处为空
 	printf("%s\n",s);
    return 0;
}
```



<br>



### 5-2 级数求和

用 `sin(x)=x−(x^3/3!)+(x^5/5!)−(x^7/7!)+⋯` 计算 sin(*x*) 的值，直到最后一项的绝对值小于 10^−5^ 时为止，输出 sin(*x*) 的值并统计累加的项数。请将函数空缺部分填写完整。

```c++
int main()
{   int n=1,count=1;
    float x;
    double sum, term;
    scanf("%f", &x );
    sum=x;
    term=x;
    do {
        term = -term*((x*x)/((n+1)*(n+2)));	// 此处为空
        sum = sum+term;
        n = n+2;
        count++;	//  此处为空
    } while (fabs(term)>=1e-5);	// 此处为空
    printf("sin(%f)=%f, total term#: %d\n",x,sum,count);
    return 0;
}
```



<br>



5-3 调整为最大堆

```c++
#define leftchild(i) ( 2*(i)+1 )

void BuildMaxHeap( ElementType A[], int N )
{  int i, j, child;
   ElementType Tmp;

   for ( i = (N-1)/2; i >= 0; i-- ) {
      j = i;
      for ( Tmp = A[j]; leftchild(j) < N; j = child ) {
         child = leftchild(j);
         if (A[child] < A[child+1])	// 此处为空
            child ++;
         if (Tmp < A[child])	// 此处为空
             A[j] = A[child];
         else  break;
      }
      A[j] = Tmp;	// 此处为空
   }
}
```



<br>



## 2020 

5-2 下列程序将 C 语言源程序 exam.c 中的注释内容（`/*` 和 `*/` 之间的部分）除去，并输出到文件 exam.out 中。请将空缺的部分补上。

```c++
#include <stdio.h>
void delcomm(FILE *fp1,FILE *fp2)     
{   int i=0;
    char c;
    while((c=fgetc(fp1)!=EOF)	// 此处有空
        if (c=='\n')  fprintf(fp2,"\n");
        else
            switch(i){
                 case 0:
                    if(c=='/') i=1;
                    else fprintf(fp2,"%c",c);  
                    break;
                case 1:
                    if(c=='*') i=2;
                    else {
                        fprintf(fp2,"/%c",c);  
                        i=0;
                    }
                    break;
                case 2:
                    if(c=='*') i=3;
                    break;
                case 3:
                    i=(
c=='/'
(2分))? 0:2;
                    break;
            }
}
int main()
{
    FILE *fp1,*fp2;
    fp1=fopen("exam.c","r");
    fp2=fopen("exam.out","w");
    delcomm(fp1,fp2;	// 此处有空
    fclose(fp1); fclose(fp2);
    return 0;
}
```



<br>



### 5-3 括号匹配

```c++
int Match( char expr[] ) 
{   char Stack[MAXS];
    int top;
    int i, ret;
    top = -1; i = 0; ret = 1;
        while (expr[i]!='\0') {
        if (expr[i]=='(' || expr[i]=='[')
            Stack[++top]=expr[i];	// 此处为空
        else if (expr[i]==')' || expr[i]==']') {
            if (top==-1)  { 	// 此处为空
                ret = 0; break; 
            }
            else  {
                if  ((Stack[top]=='(' && expr[i]!=')') 
                      || (Stack[top]=='[' && expr[i]!=']')) { 
                    ret = 0; break; 
                }
                else
                    top--;	// 此处为空
            }
        }
        i++;
    }
    if (top!=-1)  ret = 0;
    return ret;
}
```



<br>

<br>

<br>

# 函数题

### 2016、有序链表的并集与去重 (9分)

给定两个带头结点的严格降序的链表 `L1` 和 `L2`，要求你求两个链表的并集，其中元素仍然严格降序排列，且必须排除重复元素；重复的元素必须链成另一个降序排列的链表。完成去重合并后，并集链表的表头为 `L1`，重复元素链表的表头为 `L2`。

例如：`L1`→头结点→13→10→9→5；`L2`→头结点→15→10→5→2。

则合并后：`L1`→头结点→15→13→10→9→5→2；`L2`→头结点→10→5。

(这里把L1L2从下面指向头结点更好理解)

**函数接口定义：**

```c++
void ListUnion( List L1, List L2 )
```

其中`List`结构定义如下：

```c++
// 给struct Node**起别名为PtrToNode
typedef struct Node *PtrToNode;

// 定义结构体Node, 它包含2个成员：int型的key, 指向node类型的指针Next
struct Node {
    int Key;
    PtrToNode Next;
};

// 给PtrToNode起别名为List
typedef PtrToNode List;
```

要求算法额外空间复杂度为O(1)，时间复杂度为O(n)。

**裁判测试程序样例：**

```c++
#include <stdio.h>
#include <stdlib.h>

typedef struct Node *PtrToNode;
struct Node {
    int Key;
    PtrToNode Next;
};
typedef PtrToNode List;

List Read(); /* 细节在此不表 */
void Print( List L ); /* 细节在此不表；空链表将输出NULL */

// 构造函数 声明
void ListUnion( List L1, List L2 );

int main()
{
    List L1, L2;
    L1 = Read();
    L2 = Read();
    ListUnion(L1, L2);
    Print(L1);
    Print(L2);
    return 0;
}

/* 你的代码将被嵌在这里 */
```

**输入样例：**

```
4
13 10 9 5
4
15 10 5 2
```

**输出样例：**

```
15 13 10 9 5 2
10 5
```

#### 代码：

```c++
// 合并两个链表 并集降序并删除重复元素 重复元素单独形成一个降序链表
void ListUnion(List L1,List L2){
    
    // a,b为遍历两个链表的指针 tempa、tempb是a、b的前一个元素, 用于插入
    List a,b,tempa,tempb;
    a = L1->Next;
    b = L2->Next;
    tempa = L1;
    tempb = L2;
    
    // 只要ab不为空
    while(a!=NULL&&b!=NULL){
        // 当b较大时
        if(a->Key < b->Key){
            // 将b取下 
            tempb->Next = b->Next;
            
            // 将b插到a的前面
            tempa->Next = b;
            b->Next = a;
            
            // 更新b为tempb的后一个元素 a向后移动一位
            b = tempb ->Next;
            tempa = tempa->Next;
        }
        // 当ab相等时
        else if(a->Key == b->Key){
            // a、b、tmpa、tmpb均向后移动一位 重复元素在两个链表中各存在一次
            tempa = tempa->Next;
            a = a->Next;
            tempb = tempb->Next;
            b = b->Next;
        }
        // 如果a比较大时
        else if(a->Key > b->Key){
            // a向后移动
            a = a->Next;
            tempa = tempa->Next;
        }
    }
    
    if(b != NULL){
        //cout << tempa->data <<endl;
        // 将b接到tmpa的后面 tmpb后面为空
        tempa->Next = b;
        tempb ->Next = NULL;
    }
}
```



<br>



### 2017、二叉搜索树中不小于X的元素（8分）

给定一棵二叉搜索树 `T` 和一个整数`X`，要求编写函数，按**非递增序**打印出 `T` 中所有不小于 `X` 的元素。

**函数接口定义：**

```c++
void Print_NLT( Tree T, int X );
```

其中 `Tree` 定义为：

```
typedef struct TreeNode *Tree;
struct TreeNode {
    int Element;
    Tree  Left;
    Tree  Right;
};
```

**裁判测试程序样例：**

```c++
#include <stdio.h>
#include <stdlib.h>

typedef struct TreeNode *Tree;
struct TreeNode {
    int Element;
    Tree  Left;
    Tree  Right;
};

Tree BuildTree(); /* details omitted */
void Output( int X ); /* details omitted */

void Print_NLT( Tree T,  int X );

int main()
{
    Tree T;
    int X;

    T = BuildTree();
    scanf("%d", &X);
    Print_NLT( T, X );
    printf("End\n");

    return 0;
}

/* 请在这里填写答案 */
```

**输出样例1（针对图1）：**

```out
92 91 90 85 81 80 End
```

![函数题_不小于x的元素图一](assets/C语言 程序设计基础/函数题_不小于x的元素图一.png)

**输出样例2（针对图2）：**

```
End
```

![](assets/C语言 程序设计基础/函数题_不小于x的元素图二.png)

#### 代码：

```c++
void Print_NLT( Tree T,  int X ){
    if(T==NULL){
        return;
    }
    Print_NLT(T->Right,X);
    if(T->Element>=X){
        printf("%d ",T->Element);
    }
    Print_NLT(T->Left,X);
}
```



<br>



### 2018、二叉搜索树中的最近公共祖先 (8分)

在一棵树`T`中两个结点`u`和`v`的最近公共祖先(LCA)，是树中以`u`和`v`为其后代的深度最大的那个结点。现给定某二叉搜索树(BST)中任意两个结点，要求你找出它们的最近公共祖先。

**函数接口定义：**

```c++
int LCA( Tree T, int u, int v );
```

其中`Tree`的定义如下：

```c++
typedef struct TreeNode *Tree;
struct TreeNode {
    int   Key;
    Tree  Left;
    Tree  Right;
};
```

函数`LCA`须返回树`T`中两个结点`u`和`v`的最近公共祖先结点的键值。若`u`或`v`不在树中，则应返回`ERROR`。

**裁判测试程序样例：**

```c++
#include <stdio.h>
#include <stdlib.h>

#define ERROR -1
typedef struct TreeNode *Tree;
struct TreeNode {
    int   Key;
    Tree  Left;
    Tree  Right;
};

Tree BuildTree(); /* 细节在此不表 */
int LCA( Tree T,  int u, int v );

int main()
{
    Tree T;
    int u, v, ans;

    T = BuildTree();
    scanf("%d %d", &u, &v);
    ans = LCA(T, u, v);
    if ( ans == ERROR ) printf("Wrong input\n");
    else printf("LCA = %d\n", ans);

    return 0;
}

/* 你的代码将被嵌在这里 */
```

**输入样例1 （对于下图给定的树）：**

![函数题_二叉搜索树的最近公共祖先](assets/C语言 程序设计基础/函数题_二叉搜索树的最近公共祖先.png)

```
2 7
```

**输出样例1：**

```out
LCA = 6
```

**输入样例2 （对于例1中的树）：**

```in
1 9
```

**输出样例2：**

```
Wrong input
```

#### 代码

```c
// 判断树T中是否有值为x的结点
int fd(Tree T, int x) {
    if (!T)
        return 0;
    if (T->Key == x)
        return 1;
    
    // 递归左右子树
    if (T->Key < x)
        return fd(T->Right, x);
    if (T->Key > x)
        return fd(T->Left, x);
}

// 找到最近的公共祖先
int LCA(Tree T, int u, int v) {
    // 树本身为空或者树中没有uv都是error的情况
    if (!T)
        return ERROR;
    if ((!fd(T, u)) || (!fd(T, v)))
        return ERROR;
    
    // 根结点就是uv中的一个的情况 根就是结果
    if ((u == T->Key) || (v == T->Key))
        return T->Key;
    
    // uv在根节点的两侧 根就是结果
    if ((u > T->Key && v < T->Key) || (u < T->Key && v > T->Key))
        return T->Key;
    
    // 说明uv都在左边或者右边，就对左或右子树进行递归
    if (u > T->Key)
        return LCA(T->Right, u, v);
    if (u < T->Key)
        return LCA(T->Left, u, v);
}
```



<br>



### 2020、重排链表（8分）

给定一个非空的、至少有 2 个结点的链表 `L→L1→L2→...→Ln−1→Ln` ，要求你编写函数 `List Rearrange( List L )`，将链表重新排列为 `L→Ln→L1→Ln−1→L2→...`

例如：给定 L 为 1→2→3→4→5→6，则返回的链表应该为 6→1→5→2→4→3。

函数接口定义：

```c++
List Rearrange( List L )
```

其中 `List` 的定义如下：

```
typedef struct Node *PtrToNode;
struct Node {
     int   Key;
     PtrToNode  Next;
};
typedef PtrToNode List;
```

函数须返回重排列后的链表的头指针。要求算法额外空间复杂度为 *O*(1)，时间复杂度为 *O*(*n*)。

裁判测试程序样例：

```c++
#include <stdio.h>
#include <stdlib.h>

typedef struct Node *PtrToNode;
struct Node {
    int Key;
    PtrToNode Next;
};
typedef PtrToNode List;

List Read(); /* 细节在此不表 */
void Print( List L ); /* 细节在此不表 */

List Rearrange( List L );

int main()
{
    List L;
    L = Read();
    L = Rearrange( L );
    Print(L);
    return 0;
}

/* 你的代码将被嵌在这里 */
```

输入样例：

```
6
1 2 3 4 5 6
```

输出样例：

```
6 1 5 2 4 3 
```

#### 代码

```c++
List Rearrange( List L ){
    List p,q,r,s;
    p=q=L;
    while(q->Next!=NULL&&q->Next->Next!=NULL){
        p=p->Next;
        q=q->Next;
        if(q->Next!=NULL) q=q->Next;//q走两步
    }
//    printf("%d\n",p->Key);
    q=p->Next;
    p->Next = NULL;
    while(q!=NULL){//链表后半段逆置
        r=q->Next;//保存下一个节点
        q->Next = p->Next;
        p->Next = q;
        q = r;
    }
    s = L;
    q=p->Next;
    p->Next = NULL;
    List head = q;
   // printf("%d\n",q->Key);
    while(s!=NULL){
        r=s->Next;
        s->Next = q->Next;//
        q->Next = s;//
        q=s->Next;
        s = r;
    }
    return head;
}
```



<br>

<br>

<br>

# 补充

### 从源文件到可执行文件

```
预处理 -> 编译 -> 汇编 -> 链接
```

- 预处理：根据预处理命令将源代码转换为新的 c 程序，不过通常以 i 为扩展名
- 编译：将得到的 i 文件翻译成汇编代码，通常以 s 为扩展名
- 汇编：将汇编文件翻译为机器指令，并打包成可重定位目标程序的 o 文件
- 链接：将引用的其它 o 文件加到汇编后的 o 文件中，处理后得到最终的可执行文件
  





#### 关于字符串和转义字符

```c
void main(){
	char a, b, c, *p;
	a=’\’; b=’\xbc’; c=’\0xab’; p=”\0127”;
	printf(“%c %c %c %c\n”, a, b, c, *p);
}
```

编译时出现错误，以下叙述中正确的是（）
A. 程序中只有a=’\’;语句不正确
B. b=’\xbc’;语句不正确
C. p=”\0127”;语句不正确
D. a=’\’;和c=’\0xab’;语句都不正确

答案是D，不知道为什么，于是又去复习了一下c语言的转义字符。常用的c语言转义字符如下表所示：

这道题里a= ‘\’是不正确的，必须是a= ‘\\’,因为\标识转义字符，如果是 ‘\’,那\’就会被当做转义字符，字符会缺一个单引号，语法错误，需要后面再加个单引号，如a= ‘\”，但这样得到的字符就是\’了。关于b和c，转义字符\h、\hh、\hhh斜杠后面的是1~3位八进制数，该转义字符为ASCII码等于该值的字符；转义字符\xh、\xhh的\x后面的是1~2位十六进制数，该转义字符为ASCII码等于该值的字符。所以b= ‘\xbc’是对的，相当于b=0xbc，也即十进制的-68，虽然这个数对于ASCII字符没有意义，但作为char的数值是没有错的（char是带符号八位整形，取值范围为-128~127）；c= ‘\0xab’是错的，没有这个表示方法。p=“\0127”是对的，这里\012是一个转义字符，相当于八进制的12，查ASCII表可知是换行符\n，所以p相当于p= “\n7”。所以a和c变量是错的，答案选D。







<hr>




三、

```c
void f(int x) {
    if (x==0) 
        return;
    else {
        f(x/3); 
        printf("%d",x%3); 
    }
}
```

执行f(16)的结果是 121

f(16)变为f（5） + 1，再变为f(1)+21，再变为121





五、

设有以下语句，则变量 `c` 的十进制数是： `char a = 3, b = 6, c; c = a^b<<4-2;`(2分)

1. 27
2. 20
3. 78
4. 97

运算符优先级应该是减大于左移大于异或，a是0011，b是0110，b先左移两位变为011000，再和a异或得到11011，也就是27



六、


以下给出四种算法的时间复杂度，如果当 N=100 时它们对应的运行时间依次是：A 算法 100 毫秒、B 算法 30 毫秒、C 算法 20 毫秒、D 算法 10 毫秒，则当 N=200 时，哪种算法最快？ **B**

1. ```
    A. O(N)
    B. O(N^2)
    C. O(N^3)
    D. O(N^4)
    ```

    - A：原来O(N) = KN = 100	现在O(2N) = K * 2N = 200
    - B：原来O(N^2) = k * n^2 = 30 现在O(2N) = k * (2n)^2 =  120
    - C：原来O(N^3) = k * n^3 = 20 现在O(2N) = k * (2n)^3 = 160
    - D：原来O(N^4) = k * n^4 = 10 现在O(2N) = k * (2n)^4 = 160



七、

- 





C语言中，全局变量和局部静态变量是存储在静态存储区的，他们在分配的时候都被系统默认初始化为0；而局部自动变量是在栈上分配内存的，如果不对它们进行初始化，那么他们可能是任意的随机值。


（1）main函数内的变量不是全局变量，而是局部变量。

（2）只不过它的生命周期和全局变量一样长而已。

（3）全局变量一定是定义在函数外部的。





c++中 . 和 -> 主要是用法上的不同。
1、A.B 则A为对象或者结构体；
2、A->B 则A为指针，->是成员提取。A->B是提取A中的成员B，A只能是指向类、结构、联合的指针；

```
p->val 和 (*p).val使用上等价
```



