参考书籍：C语言程序设计 何钦铭（第三版）

<hr>

# 一、 数据表达与组织

## 1.1 常量、变量、运算、表达式

**C语言标识符** ：由 `字母` 、 `数字` 、 `下划线` 组成，且必须是 `字母` 或 `下划线` 开头，且 **区分大小写**

标识符分为：

- **关键字（保留字）** ： 如 `typedef` 、`int` 、 `if` 、 `return` 等
- **用户定义的标识符**



<br>



**C语言中的数据类型：**

- **整型** 
    - 有符号整形 (`int` 、 `short` 、 `long` 、 `long long` )：int占4字节
    - 无符号整形 ( `unsigned int` 等)
- **字符型 (char)** ：表示单个字符，用单引号占一字节，本质是该字符表示的ASCII值（整型）
    - 'A'：65 ， 'a'：97
- **浮点型(实型)**
    - 单精度float
    - 双精度double    `%08.3f\n` 表示显示8位数（包含小数点）， 不足8位用0填充，且保留3位小数
- **布尔(_Bool)**
    - 1表示 `true` ，0表示 `false` 



<br>



**关于字符串：**

c语言中没有字符串类型，但有字符串的概念，同时 `string.h` 中也有着相关操作字符串的函数

字符串（常量）是以NULL结尾的0个或多个字符组成的序列，常量所以不可修改，并用双引号，例如 `"Hello!"` ， `"123abc\n"`

字符串结尾默认有个空字符 `'\0'`

字符串常量与指针关系密切

因为字符串常量的值，实际上表示的是 **存储这些字符的内存空间的地址** ，更准确地说是 **字符串常量中第 1 个字符的地址** ，而 **不是这些字符本身**

因此，在 C 语言中不能直接进行字符串赋值，常通过声明一个指向 char 类型的指针并将其初始化为一个字符串常量的方式来访问一个字符串：

```c
char *msg = "Hello World!";
 
// 上面的语句也可以拆分成下面两句
char *msg;
msg = "Hello World!";　　　　// 这句话看起来像是字符串复制，其实不是，只是涉及到指针操作

// 可以进行遍历
while(*msg != '\0'){
	printf("%c ",*msg++);
}
```



<br>



**关于字符数组：**

在 C 语言中，除了字符串常量外， **其他所有字符串都必须存储于字符数组或动态分配的内存中**

定义和普通数组一样，只不过存放的元素是char类型的

```c
// 声明并初始化一个字符数组 下面两个效果一样
char str[] = {'H','e','l','l','o'};    
char str[] = "Hello World!";

// 可以进行修改 将小写变大写
for(int i = 0; i < strlen(str); i++){
	if( str[i] <= 'z' && str[i] >= 'a')
		str[i] = str[i] - 32;
}
```



<br>



**字符串常量和字符数组的区别：**

- 字符串常量是一个字符数组，但是内容和长度在初始化时就已经固定了， **不可更改** ；可以通过一个指向字符串常量第一个元素的指针来访问该字符串常量；

- 字符数组是一个用于存放字符的数组，字符数组的值是 **可以更改的** 



<br>



**常量** ：程序运行中不能被改变的量

**变量** ：程序运行中可以被改变的量

```c
// 声明一个变量
类型说明符 变量名A, 变量名B = B的初始值;
```



<br>



**运算：**

- **算术运算** ：`+` 、 `-` 、`*` 、`/` 、`%（只用于int）`（当双目运算符两边类型不同时，会自动进行类型转换）
- **赋值运算** ：`=` 左边必须是变量，右边计算完后会自动转化为左边的类型，再赋予左边
- **关系运算** ： `>` 、`<` 、 `!=` 等
- **位运算** ： 按位取反，按位与，左移右移等（操作数的移位不改变原操作数的值，除非通过赋值）

**（重要）运算符的优先级（数字越小越优先）和结合性（没写就是左到右，操作数两边的优先级相同时，先与左边的运算符结合）：**

1. 括号 `[]` 和 `<>` 、成员选择 `.` 和 `->` 
2.  `逻辑非!`     **右到左**
3. `单目-` ， `按位取反~` ， `自增++ 自减--` ，`指针取值*` ， `取地址&` ， `强制类型转换` ， `sizeof`    **右到左**
4. 乘，除，取模
5. 加，减
6. 左移<< ， 右移>> 
7. 大于，小于，大于等于，小于等于
8. 等于，不等于
9. 按位与&
10. 按位异或^
11. 按位或|
12. 逻辑与&&
13. 逻辑或||
14. 三目条件运算符 `?:`    **右到左**
15. 赋值运算符一类，包括 `=` ，`+=` 等    **右到左**
16. `,` 运算符

总结：

- 同一优先级的运算符，运算次序由结合方向所决定

- 简单记： `！> 算术运算符 > 关系运算符 > && > || > 赋值运算符`

    



<br>



**表达式：** 由运算符和操作数组成的有意义的运算式子

- 常量表达式：a

- 算术表达式：a+b

- 赋值表达式：a=1    **计算右边的值，再赋予左边，左边的值就是整个赋值表达式的值**

- 关系表达式：a>b    **关系表达式的值是整型，1或者0**

- 逻辑表达式：a&&b    **可以是任何类型，非0表示真，0表示假**

- 条件表达式：`a?b:c`

- 复合表达式

- 逗号表达式：`a,b` 按顺序执行，整个逗号表达式中每个语句都会被计算到，整个逗号表达式的值为最后一个表达式的值。作为条件的时候，非0真，0假

    ```c
    //执行时a的值会自增1，b的值也会自增1，最终将b自增后的值赋给变量z
    //此时z的值为5，也就是最终整个逗号表达式的结果。
    int a = 3,b = 4,z = 0;
    z = ++a,++b;	
    ```

    





<br>



## 1.2 一维和二维数组，字符数组和字符串



<br>



## 1.3 指针与数组，结构与数组



<br>



## 1.4 指针与结构，单向链表



<br>

<br>

<br>



# 四、输入/输出和文件

## 4.1 标准输入和输出

### 4.1.1 标准输入 scanf()

引入头文件：

```c
#include<stdio.h>
```

一般格式为：

```c
scanf(格式控制字符串, 参数1, …… ，参数n)
    
例如：
scanf("x=%lf", &x);

scanf("%d%d", &n, &m); // 可以正确读入20 30，因为scanf在处理输入时，如果格式占位符不是%c，它就会将空白字符（空格符、制表符和换行符）都视为一次输入的终止标记
scanf("%c %c", &n, &m);// 如果是%c,需要加上空格，否则m会变为空格
```

- 格式控制字符串用 **双引号** ， 包含：
    - `格式控制说明(格式占位符)` ：例如 `int型` 需要 `%d` ， `float` 需要 `%f` ， `double` 需要 `%lf`
    - `普通字符` ：原样输入的字符，一般会尽量避免在scanf中使用普通字符
- 参数是变量的地址
- 参数和格式控制说明要一一对应







<br>



### 4.1.2 标准输出 printf()

引入头文件：

```c
#include<stdio.h>
```

一般格式为：

```c
printf(格式控制字符串, 参数1, …… ，参数n)
    
// 输出浮点型时的格式控制
%+a.bf    
%-a.blf
a:输出数据的宽度 不足补空格
b:小数位
+: 右对齐 不写默认是右对齐
-: 左对齐
printf("%3.3lf\n",1.3345);    //有效小数位数是 3 位 最后一位5没有打印,四舍五入往前进了一位
```

- 格式控制字符串用 **双引号** ， 包含：
    - `格式控制说明(格式占位符)` ：例如 `int型` 需要 `%d` ， `float` 和 `double` 需要 `%f`
    - `普通字符` ：原样输出的字符
- 参数是输出的数据，可以是常量、变量、表达式
- 参数和格式控制说明要一一对应



<br>

格式占位符：

|   **于有符号整型**   | **%d or %i** |
| :------------------: | :----------: |
|     **用于字符**     |    **%c**    |
|    用于无符号整型    |      %u      |
|   **用于单浮点数**   | **%f or %F** |
| **用于双精度浮点数** |   **%lf**    |
|    **用于字符串**    |    **%s**    |





<br>



| 常用的转义字符 |                   效果                   |
| :------------: | :--------------------------------------: |
|       \n       |                   换行                   |
|       \r       | 换行(回到当前行首)，判断按键是否是回车键 |
|       \t       |                 水平制表                 |



<br>



## 4.2 文本文件和二进制文件

### 4.2.1 文件的定义：

C语言中的文件类似于数组、结构等，是一种数据组织方式，是C语言程序处理的对象

C语言把文件看作数据流，并按一维方式组织存储（像磁带）



<br>



### 4.2.2 文本文件、二进制文件

**文本文件/字符文件** ： 以字符ASCII码值进行存储和编码的文件，内容就是字符

**二进制文件** ： 存储二进制数据的文件

C语言的 **目标文件（.o）** 和 **可执行文件（.exe）** 是二进制文件，包含给计算机识别的机器代码





<br>



## 4.3 文件打开、关闭、读写和定位

**文件缓冲系统：**

进行文件操作时，在程序和文件之间的一个内存缓冲区，来进行数据交换

缓冲文件系统中，系统 **自动分配** 一块文件缓冲区（内存单元），且数据处理只考虑文件缓冲区即可，内存和磁盘之间是操作系统的事



<br>



### 4.3.1 文件处理步骤

1. 定义文件指针  `FILE *fp` ，fp为指向文件结构的指针， 注意不能用fp++和*fp
2. 打开文件：文件指针指向磁盘文件缓冲区
3. 文件处理：对文件进行读写操作
4. 关闭文件



<br>



### 4.3.2 打开文件

打开文件操作由 `fopen()` 实现

```c
FILE fp;
fp = fopen("文件名", "文件打开方式");
```

- 成功，返回包含文件缓冲区等信息的FILE结构地址，赋予文件指针fp；否则（文件不存在，被其他软件打开，本身错误等等）返回一个NULL的FILE指针
- 文件名是字符串，指明文件的路径：默认是当前的文件夹，否则就是完整路径，例如 `c:\\abc.txt` 此处用了转义符

关于文件打开方式：

（下面是 **文本文件（ASCII）** 的文件打开方式）：

| 使用方式 |           含义           |
| :------: | :----------------------: |
|    r     |   打开文件， **只读**    |
|    w     | **新建** 文件， **只写** |
|    a     |   打开文件， **追加**    |
|    r+    |     打开文件，读/写      |
|    w+    |   **新建** 文件，读/写   |
|    a+    |   打开文件，读/写/追加   |

- 只有w是新建，其他都是打开
- +代表功能的增加
- 对应的换成二进制文件只要加个b，例如从 `w+` 变为 `wb+`
- 文件打开的实质是将磁盘文件和文件缓冲区对应
- 打开之后，对文件的读写操作只需要使用文件指针，且已经打开，操作方式就已经被确定，关闭之前都不能改变
- 可以同时打开多个文件，但不允许同一个文件在关闭之前被再次打开



<br>



例如打开文件abc.txt，只读的两种方式：

```c
fp = fopen("abc.txt", "r");	// 字符串常量代表文件

char *p = "abc.txt";	// 字符指针表示文件
fp = fopen(p, "r");

if((fp = fopen("abc.txt", "r")) == NULL){
   	文件出错;
    exit(0);	//exit(0) 是系统标准函数, 关闭所有打开的文件并终止程序。0表示正常结束, 其他表示非正常结束
}
```



<br>



### 4.3.3 关闭文件

数据写入文件，首先是先写到文件缓冲区，缓冲区满（512B）才真正写到磁盘

在写满之前程序中止，这部分数据就会丢失

文件关闭可以强制使缓冲区中的数据写入磁盘

关闭文件操作由 `fclose()` 实现

```c
fclose(文件指针);
```

- 返回值为整数，0表示正常关闭
- fclose() 将释文件缓冲区单元和FILE结构，解除文件和文件指针的关联
- 文件使用结束完要及时关闭文件





<br>



### 4.3.4 文件读写

标准库stdio.h中的一些函数

#### 字符方式文件读写 fgetc() 和 fputc()

对于文本文件，操作的数据都是ASCII字符文本



```c
ch = fgetc(fp);	// 从fp指向的文件中读一个字符到ch, 只要成功, fp就会自动移到下一个位置。 失败, 返回EOF 	补充：类似getchar(), 从键盘中读一个字符
fputc(ch, fp);	// 将ch写到fp所指的文件		成功返回ch, 失败返回EOF(值为-1) 补充：类似putchar(), 将ch显示在屏幕
```

- 文件缓冲区中的位置会随着fgetc()和fputc()而自动改变
- 实际上是对文件缓冲区进行读写
- 不要在程序中用fp++来改变文件缓冲区的位置，fp指向的是文件结构

实现从A文件写数据到B文件：

```c
#include<stdio.h>
#include<stdlib.h>

int main(void){
    FILE *fp1, *fp2;
    char ch;
    
    // 打开两个文件
    if((fp1 = fopen("a.txt", "r")) == NULL){
        printf("a错误！\n");
        exit(0);
    }
    if((fp2 = fopen("b.txt", "w")) == NULL){
        printf("b错误！\n");
        exit(0);
    }
    
    // 进行复制 
    while(!feof(fp1)){  // feof()判断是否到了文件尾
        ch = fgetc(fp1);
        if(ch != EOF)   // 因为feof()在末尾之后再一个循环才会变成true 例如最后一个字符是'a'，此时feof是false，再读一次返回EOF，feof才是true
            fputc(ch, fp2);
    }
    
    // 关闭文件
    if(fclose(fp1)){
        printf("a 无法关闭！\n");
        exit(0);
    }
    if(fclose(fp2)){
        printf("b 无法关闭！\n");
        exit(0);
    }
    
    return 0;
}
```



<br>



#### 字符串方式文件读写  fgets() 和 fputs()

读写文件时以字符串为单位

```c
fgets(s, n, fp);	// 从文本中读字符串
```

- s不能为字符串常量
- fp是文件指针
- n为读取的字符个数，最多读取n-1个字符，并存入s指向的内存地址开始的n-1个连续单元
- 到指定个数、遇到换行符、EOF时，自动加上一个 `\0` ，换行符会保留，EOF不会保留
- 成功返回字符串；否则返回空指针，此时s中的内容不确定



```c
fputs(s, fp); 	// 向文件中写入字符串
```

- s可以是字符数组名、字符型指针变量、字符串常量
- fp是文件指针
- 写入的时候字符串结束符 `\0` 不写入
- 成功返回最后一个字符；否则返回EOF



<br>



#### 格式化方式读写 fscanf() 和 fprintf()



```c
fscanf(文件指针, 格式化字符串, 输入表);
fprintf(文件指针, 格式化字符串, 输入表);

// 从文件中读入整形n, 浮点型x
fp = fopen("a.txt", "r");
fscanf(fp, "%d%f", &n, &x);

// 将n和x写入文件
fp = fopen("b.txt", "w");
fprintf(fp, "%d%f", n, x);
```

- 类似于scanf()和printf()
- 格式转化计算机会自动完成



<br>



#### 其他相关函数：

和文件定位相关的函数：

- `rewind()` ：回到文件的首地址 `rewind(FILE *fp);`
- `fseek() ` ：控制文件读写指针移动 `fseek(fp, offset, from);` from可取012，表示开头、现在和末尾
- `ftell()` ：获取当前文件读写指针的位置，即相对开头的位移量 `ftell(文件指针)`

检测文件指针状态的函数：

- `feof()` ： 判断是否读到了EOF，成功返回true
- `ferror()`
- `clearerr()`



<br>

### 4.3.5 习题

1. `printf("%d %d %d", NULL, '\0', EOF);` 的结果是： **0 0 -1** 
2. 如果二进制文件a.dat已经存在，现在要求写入全新数据，应该用 **"wb"** 方式
3. `FILE *fp;` ，则文件指针指向的是 **文件类型结构**
4. 缓冲文件系统的文件缓冲区位于 **内存缓冲区中**
5. 文件的三大特征： **名称、大小、类型**
6. `fopen()` 的返回值是 **指向文件缓冲区的首地址的文件结构类型指针**
7. 缓冲文件系统和非缓冲文件系统的区别： **系统是否为文件自动分配一块文件缓冲区（内存单元）**



<br>

<br>

<br>



# 五、编译预处理和命令行参数

## 5.1 宏定义和宏函数

### 5.1.1 宏定义

通常用于符号常量定义，实现简单函数，或者为了书写更方便

**格式：**

```c
#define 宏名 宏定义字符串
```

- 在编译预处理中起作用（编译时，将代码中有宏名的地方用宏定义字符串来 **替换** ），不是真正的C语句
- 末尾没有分号（有分号的话分号也会替换进去）
- 宏名中间无空格，宏定义字符串随意，回车符作为结尾
- 如果一行太长，可以用 `\` 下一行继续写

**可宏嵌套定义：**

```
#define PI 3.14
#define S PI*r*r
```



<br>



### 5.1.2 宏函数

```c
#define MAX(a, b) a>b?a:b

x = MAX(x, y);
```

**和函数调用的区别：**

- 宏定义在编译预处理时完成，进行替换。**宏定义只做替换，不做计算**
- 函数调用在程序执行时才进行，并且传参，**计算表达式后返回**

**为了防止出错，要加括号：**

```c
// y会变成x+y*x+y 出错
#define SQR(x) x*x
y = SQR(x+y);

// 替换时括号会保留 这样就不会出错
# define SQR(x) (x) * (x)
```

**配合逗号表达式：**

```c
// 这样会出错
#define ALERT(str)  {putchar('\a');puts(str);}
// 替换为 if(n) {putchar('\a');puts(str);};
if(1) ALERT("hhh");

// 正确 整个逗号表达式中每个语句都会被计算到 
#define ALERT(str)  {putchar('\a'),puts(str);}
// 替换为 if(n) {putchar('\a'),puts(str);};
if(1) ALERT("hhh");
```



<br>



## 5.1 命令行参数和使用

C语言源程序经过编译和连接生成可执行文件（可执行程序/可执行命令）后，可以在操作系统环境中用命令方式来执行

例如用命令 `test` 来执行当前目录下的 `text.exe`

而一个命令行中可以包括命令和参数（也可没用，用空格分开），这些参数就是 **命令行参数**

```
命令 参数1 参数2 
```

C语言中主函数可以有两个参数：

```c
int main(int argc, char *argv[]){}
```

- argc 为命令行参数（包括命令）的个数
- argv 以字符串常量方式存每个命令行参数：argv[0]是命令，argv[1]是参数1…… argv实际上还是指针，指向数组的首地址，可以修改 `*(argv++)`
- 可以取其他名字，这两个是约定俗成



<br>



例如：

echo.c:

```c++
#include<stdio.h>

int main(int argc, char *argv[]){
	// 打印命令行参数
	for(int k = 1; k < argc; k++)
		printf("%s", argv[k]);
		
	return 0;
}
```

命令行下输入：

```
echo are you ok？
```

输出

```
are you ok？
```



<hr>


# 补充

### 从源文件到可执行文件

```
预处理 -> 编译 -> 汇编 -> 链接
```

- 预处理：根据预处理命令将源代码转换为新的 c 程序，不过通常以 i 为扩展名
- 编译：将得到的 i 文件翻译成汇编代码，通常以 s 为扩展名
- 汇编：将汇编文件翻译为机器指令，并打包成可重定位目标程序的 o 文件
- 链接：将引用的其它 o 文件加到汇编后的 o 文件中，处理后得到最终的可执行文件
    













<hr>



杂记：

一、

```c
typedef int  *INTEGER;
INTEGER a,*b;
```

typedef的作用是起别名，INTEGER就是int*的别名

所以第二行的相当于

```
int* a,*b;
```

a是 `int` 型的指针变量

b是指向「指向整型的指针」的指针

-----

使用关键字 **typedef** 可以为类型起一个新的别名。

typedef 的用法一般为：typedef  旧名字  新名字;



二、

程序输出结果是：

```
int k=2, s=0; 
switch(k) { 
    case 2: 
        s++; 
        k++;
    case 1: 
        s++; 
    case 3: 
        s+=1; 
    
    switch(s){ 
        case 2: 
            s+=2; 
            break; 
        default: 
            k++; 
            break; 
    } 
    default: 
        s+=3; 
} 

printf("%d#%d#", s, k);
```

结果是6#4#



三、

```
for(i=1; i++ <4; );
```

后i的值为5



四、

```
int k = 4, s = 0;
while(k--)s+=k;
```

之后k和s的值为：-1 6
