# 第一章 计算机系统概述

## 重点:

以选择题为主

## 1.1 OS基本概念

### 1.1.1 概念、特征

**操作系统** ： 是对计算机资源（软硬）进行管理的系统软件

**操作系统的基本特性 ：** 

- **并发 ：** 

    两个或多个事件在同一时间间隔内发生

    通过 **分时** 实现

    需要硬件支持，例如多流水线、多处理机

- **共享 ：** 

    资源可以供多个并发的进程使用

    **临界资源** ： 一段时间内只允许一个进程访问的资源，只能互斥式共享，例如栈、变量、表格

    允许被同时（微观上还是分时共享的）访问的资源，例如磁盘

- **虚拟：**

    **时分复用技术** ：处理器的分时共享

    **空分复用技术** ：虚拟存储器

- **异步：**

    走走停停，速度不可知

其中并发和共享是最基本的特性，他们互为存在的条件



<br>



### 1.1.3 操作系统的功能

**管理功能：**

- **处理机管理**

    也就是对进程的管理，主要任务是 合理共享

    控制、同步、通信、死锁、处理机调度等

- **存储器管理**

    内存分配和回收、地址映射、内存保护和共享、内存扩充

- **文件管理**

    文件存储空间管理、目录管理、文件读写和保护

- **设备管理**

    缓冲管理、设备分配、设备处理、虚拟设备



<br>



**作为用户和硬件的接口：**

- **命令接口**

    利用操作命令来组织和控制作业执行

    - **联机控制方式（交互式命令接口）** ： 说一句，做一句
    - **脱机控制方式（批处理命令接口）** ： 按清单上的做 

- **程序接口（即系统调用）**

    来请求操作系统服务

    由一组 **系统调用（广义指令）** 组成，系统调用是OS为应用程序使用内核功能提供的接口，只能通过用户程序间接使用



<br>



### 1.1.4 习题

#### 选择题

1. 操作系统与用户通信接口通常不包括：`缓存管理指令`

    ```
    其余选项 shell、命令解释器、广义指令
    
    广义指令就是程序接口
    命令解释器属于命令接口的联机控制方式
    shell是命令解释器
    ```

    

2. 不属于多道程序设计的基本特性是： `顺序性`

    ```
    引入多到程序设计后，失去了封闭性和顺序性
    顺序性是单道程序设计的特点
    ```

    



<br>



## 1.2 OS发展历程

1. **手工操作**

    **无操作系统**

    用户独占全机

    CPU等手工操作，利用不充分

2. **批处理**

    **有操作系统**

    对作业的处理成批进行

    - **单道批** ：内存中只有一道程序

        为了解决人机矛盾和CPU、I/O速度不匹配矛盾产生

        自动性，逐个运行

        **顺序性**

    - **多道批** ：内存中有多道程序

        为了提高资源利用率和系统吞吐率

        **宏观上并行，也就失去了顺序性**

        **微观上串行，轮流占用CPU**

3. **分时操作系统**

    解决了多道批的用户交互差的问题

    将时间分为时间片

    **同时性**

    **交互性**

    **独立性**

    **及时性（时间短，但还是不够短）**

4. **实时操作系统**

    **任务很紧急的情况** 

    - 硬实时：飞行器控制
    - 软实时：飞机订票

    特点是 **及时性** 、 **可靠性**

    



<br>



### 1.2.7 习题

#### 选择题

1. 【2016】中断技术使得多道批处理系统的I/O设备可与CPU并行工作 `正确`

    ```
    多道批
    当一个程序进入到I/O的时候，CPU不会傻傻的等待，而是去运行另一道程序，此时I/O和CPU并行
    ```

    

2. 【2018】下列关于多任务操作系统的叙述中：

    ```
    具有并发和并行的特点	正确，多任务系统要在同一时间内运行多个应用程序
    需要运行在多CPU的硬件平台上	错误，并不一定要多CPU，单CPU多核也可以
    ```

    



<br>



## 1.3 OS运行环境

### 1.3.1 处理器运行模式

CPU运行两种程序：

- 操作系统的 **内核程序**

    访问需要特权指令，不允许用户直接用

    例如 `I/O` 、 `置中断` 、 `存取保护的寄存器` 、 `写程序状态字寄存器` 等

- 用户的 **应用程序**

    可以用非特权指令，用户直接用，只能访问用户的地址空间

CPU运行状态：

- 用户态（目态），可以通过 **访管/trap/陷入指令** 进入管态（ **所以肯定是在用户态运行！** 
- 核心态（管态）

操作系统内核包括：

1. **时钟管理**

    计时、时间片、时钟中断实现进程切换等等

2. **中断机制**

    保护和恢复现场的功能属于内核

3. **原语**

    最底层，最接近硬件

    **原子性** ，必须一气呵成

4. **系统控制的数据结构及处理**

    例如PCB、FCB、消息队列、缓冲区、内存分配表等



<br>



### 1.3.2 中断和异常

对资源占有权的释放离不开中断





<br>



### 1.3.3 系统调用

系统调用就是提出请求给操作系统

可视为特殊的公共子程序

和资源相关的操作都是通过系统调用，由操作系统代为完成，包括：

- 设备管理
- 文件管理
- 进程控制
- 进程通信
- 内存管理

**执行系统调用的过程主要包括以下操作：**

1. 传递系统调用参数
2. 执行响应的服务程序
3. 执行陷入/访管指令
4. 返回用户态



<br>



### 1.3.4 习题

#### 选择题

1. 核心态到用户态的转换是操作系统完成的，用户态到和心态的转换是 `硬件` 完成的

    ```
    选了中断处理程序，但中断处理程序一般也在核心态执行
    ```

2. 只能在核心态下运行的指令时 `广义指令`

    ```
    广义指令就是系统调用命令
    题目说运行，那么系统调用只能工作在核心态
    用户态下是调用广义指令，然后核心态代为执行
    ```

    

3. CPU处于核心态下可以执行的指令时 `除访管指令的全部指令`

    ```
    和心态可以执行任何指令，但是访管指令时只有用户态能用的
    ```

    

4. 【2012】不可能在用户态发生的事件是 `进程切换`

    ```
    看其他选项：
    系统调用，用户态和核心态都有
    外部中断, 用户态和核心态都有
    缺页，访问虚存时缺页，用户态->内核态
    
    进程切换, 只发生在核心态，因为涉及处理机调度和资源
    ```

    

5. 【2015】处理外部中断时，应该由操作系统保存的是 `通用寄存器的内容`

    ```
    外部中断处理过程
    PC的值由中断隐指令自动保存，通用寄存器的内容由操作系统保存
    ```

    

6. 【2016】访存时缺页属于 `异常` ， 存储保护错属于 `异常`

    ```
    中断和指令无关，异常来自于当前执行的指令
    
    访虚存时缺页和当前执行的指令有关
    ```

    

7. 【2018】定时器产生时间中断后，由时钟中断服务程序更新的部分内容是：

    ```
    内核中时钟变量的值、当前进程占用CPU的时间、当前进程在时间片内的剩余执行时间
    
    和时间有关的都对，全选
    ```

    

8. 【2020】下列和中断相关的操作中，由操作系统完成的是：

    ```
    提供中断服务、初始化中断向量表、保存中断屏蔽字
    
    保存中断程序的断点（PC中的内容）是由硬件自动完成的
    ```

    



<br>



## 1.4 OS结构

#### 分层法

最底层0为硬件，最高层N为用户接口，每层只能调用它的上一层的功能和服务（单项依赖），像个靶子那样的

优点：

- 便于调试和验证
- 易扩充和维护

缺点：

- 合理定义 困难
- 销量较差，要穿很多层的话，都有各自的通信机制



<br>



#### 模块化

按功能划分为若干有一定独立性的模块，各模块通过接口通信（模块-接口法），像是树型结构

好的模块是高内聚，低耦合的

优点：

- 正确性、可理解性、可维护性高
- 各模块一起设计，无法建立在一个已经验证的模块的基础上



<br>



#### 宏内核

也称单内核、大内核

主要功能模块作为一个紧密联系的整体运行在核心态

windows、Android、ios、macos、linux等



<br>



#### 微内核

最基本的功能保留在内核，其余放到用户态执行

移出内核的操作系统代码根据 **分层原理** 划分成若干服务程序，独立运行，借助微内核提供的消息传递机制进行通信

一个模块的崩溃只会使这个模块崩溃，而不会使整个系统崩溃

操作系统分为：

- 微内核：包含硬件处理相关、客户和服务器的通信
- 多个服务器：（我理解为同一个功能，比如进程管理，核心代码在内核，不太核心的放在服务器上）

**采用C/S模式** 

采用 **机制与策略分离** 的原理来构造OS结构， 机制部分和硬件相关的放入微内核，绝大部分放到微内核外的服务器实现

微内核基本功能：

- 进程（线程）管理
- 低级存储器管理
- 中断和陷入处理

优点：

- 扩展性和灵活性
- 可靠性和安全性
- 可移植性
- 更好地支持分布式

缺点：

- 性能问题，因为要频繁切换用户态和核心态， **不够高效** 



<br>



#### 外核

保持多个虚拟机彼此不发生冲突

优点：

- 减少了映射层



<br>



## 1.5 OS引导

操作系统也是程序，启动操作系统的过程：

1. **激活CPU**

    CPU读取 **ROM中的boot程序** ，执行BIOS的指令（将指令寄存器设置为BIOS的第一条指令）

2. **硬件自检**

3. **加载带有OS的硬盘**

    BIOS读取Boot Sequence，将控制权交给顺序第一的存储设备，CPU将 该**存储设备引导扇区的内容加载到内存**

4. **加载主引导记录MBR**

    一个一个找引导硬盘， **MBR的作用就是告诉CPU操作系统在哪个硬盘的哪个分区**

5. **扫描硬盘分区表、加载硬盘活动分区**

    MBR中有硬盘分区表，记录了活动分区和非活动分区， **找到含操作系统的活动分区并加载** ，控制权交给活动分区

6. **加载分区引导记录PBR**

    读取活动分区的第一个扇区（称为分区引导记录PBR），为了找到并激活活动分区根目录下用于引导OS的程序（启动管理器）

7. **加载启动管理器**

8. **加载操作系统**





<br>



## 1.6 虚拟机

虚拟机就是隐藏了物理特性，逻辑上的计算机，分为两类：

- **第一类虚拟机管理程序（裸金属架构）** ： **运行在裸机上**

    有多道程序功能，向上层提供若干虚拟机（都是裸机的复制品）

    虚拟机作为用户态的进程，不能执行敏感指令（虚拟机的操作系统以为自己是内核态，实际上使用户态）

    - 如果是 **支持虚拟化的机器** ，虚拟机的操作系统执行敏感指令，虚拟机管理程序能其 **正确执行**， 用户执行，虚拟机管理程序将 **模拟**
    - 不支持虚拟化的机器， **都模拟**

- **第二类虚拟机管理程序（寄居架构）** ： **运行在宿主OS上**

    运行在硬件上的是宿主OS，虚拟机更像一个伪装成有CPU和设备的进程，被称为客户OS

    虚拟磁盘只是宿主OS中的一个文件夹
    
    **VMware**

注 ： 软件、硬件都可以实现虚拟机



<br>



### 1.6.2 习题

#### 选择题

1. 采用微内核结构，不宜放在微内核中的有：

    ```
    文件系统服务，在文件服务器中
    
    其余选项
    进程间通信机制，最频繁，放内核
    低级I/O，和硬件相关，放内核
    低级进程管理和调度， 属于调度功能的机制部分，放内核
    中断和陷入处理，放内核
    ```

    

2. 操作系统的引导程序位于 `硬盘`

    ```
    装有操作系统的硬盘的活动分区的引导扇面中的引导程序（也就是启动管理器），用于引导操作系统
    
    另外还有用于启动设备的引导程序，位于ROM中的自举程序（BIOS的组成部分）
    ```

    

3. 计算机启动的过程是：

    ```
    1. CPU加电
    2. 执行JMP指令跳转到BIOS
    3. 等级BIOS中断例程入口地址
    4. 硬件自检
    5. 进行操作系统引导
    
    关键：先BIOS再自检
    ```

    

4. 多台虚拟机可同时运行在同一物理机器上，实现了真正的并行 `错误`

    ```
    实现了真正并行的是多核处理机
    多个虚拟机就相当于多个程序
    ```



<br>

### 并发性和并行性

- 并发：同一个时间间隔内发生，微观只有一道，宏观看有多道
- 并行：同一时刻有多个同时发生，例如多处理器

### 特权指令和非特权指令

- 核心态：能运行除访管指令外的全部指令
- 用户态：只能运行非特权指令

### 访管指令

访管指令能产生一个访管中断，将操作系统转为核心态，访管中断处理程序将按系统调用的操作数和参数转移到相应的例行子程序，完成后回到断点



# 第二章 进程与线程

## 重点：

进程必考

- 选择题

- 综合题：信号量机制实现同步和互斥

## 2.1 进程与线程

### 2.1.1 进程的概念和特征

进程（动态的） ： 程序实体的运行过程，系统进行资源分配的独立单位，动态，为了实现OS的并发性和共享性引入的概念

进程控制块PCB ： 用来描述和控制进程，是进程存在的唯一标志

进程实体（进程映像，静态的） ：

- 程序段
- 相关数据
- PCB

进程的特征：

- 动态性
- 并发性
- 独立性
- 异步性



<br>



### 2.1.2  进程的状态与转换（重要）

进程的状态（前三种是基本状态）：

- **运行态**

- **就绪态：**

    进程获得了 **除处理机外的一切资源** ，就绪队列

- **阻塞态（等待态）：**

    等待某一事件（等待非处理机的资源，等待I/O等）而暂停运行，有处理器也不能运行。根据原因放在多个阻塞队列

    **只能由运行态进入**

- **创建态：**

    创建的过程中，结束到就绪态

    申请空白PCB、写入控制和管理进程的信息、分配资源、转入就绪队列

    如果资源不能得到满足，仍然处于创建态

- **结束态：**

    先设为结束态，再回收资源

补充：

- 运行态到阻塞态（比如等待I/O）： **主动**
- 阻塞态到就绪态（资源到手)  ： **被动**

![第二章_进程5种状态的切换](assets/操作系统笔记/第二章_进程5种状态的切换.png)



<br>



### 2.1.3  进程的组织（先跳过）



<br>



### 2.1.4  进程控制（先跳过）



<br>



### 2.1.5  进程的通信

PV操作属于低级通信，高级通信有：

- 共享存储
- 消息传递
- 管道通信



<br>



### 2.1.6 线程和多线程模型

引入进程的目的 ： 为了更好地实现多道程序的并发执行，提高资源利用率和系统吞吐量

引入线程的目的 ： 减少程序在并发执行时付出的时空开销，提高并发性能

线程 ： 

- 系统调度的基本单位
- 同个进程的所有线程共享全部资源
- 线程切换开销少，同一个进程内的线程切换不会切换进程
- 支持多处理机系统

线程的状态：

- 运行态
- 就绪态
- 阻塞态



<br>



#### 用户级线程ULT（线程库支持的线程）

用户在用户空间用 线程库 编写的多线程程序

**内核意识不到线程的存在**

调度仍然以 **进程** 为单位

**优点：**

- 线程切换不需要切换到内核空间，开销少
- 调度算法可以根据情况设置
- 和操作系统平台无关

**缺点：**

- 一个线程阻塞，同个进程的所有线程都阻塞
-  **只有一个线程能用处理机** ， 不能发挥多处理机的优势

**线程库：** 分为有无内核支持两种

-  Pthreads
- Windows API
- Java 线程 API



<br>



#### 内核级线程KLT（内核支持的线程）

在内核的支持下运行，内核空间为每个线程设置一个线程控制块

**优点：**

- 能用多处理机
- 一个阻塞，不影响其他
- 线程切换快，开销少
- 内核本身也可用多线程技术

**缺点：**

- 统一进程中切换线程， **需要从用户态切换到核心态** （用户程序的线程在用户态，线程管理在核心态），系统开销大



<br>



#### 组合方式

用户级线程通过 **时分复用内核级线程** 实现

有ULT和KLT的优点，克服了缺点



<br>



#### 多线程模型

- **多对一**

    多个用户线程映射到一个内核线程

    **优** ：销量高

    **缺** ： 一个阻塞其他也阻塞，不能用多处理机 

- **一对一**

    **优** ： 一个阻塞，运行调度另一个运行，并发能力强

    **缺** ： 每有一个用户线程就要创建一个内核线程，开销大

- **多对多**



### 2.1.8 习题

#### 选择题







<br>



## 2.2 处理机调度

### 2.2.1 调度的概念

**调度的层次：**

（操作次数由高到低）

- **作业调度（高级）**

    从外存选一个或多个作业放入内存，分配资源，创建进程

    每个作业一次调入、一次调出

- **内存调度（中极）**

    目的 ：提高内存利用率和系统吞吐量

    暂时不能运行的调入外存， 挂起态

    实现挂起态->就绪态

- **进程调度（低级）**

    给就绪队列的进程分配处理机



<br>



### 2.2.2 调度的目标

就是为了性能指标优秀

#### CPU利用率

```
CPU利用率 = CPU工作时间 / (CPU工作时间 + CPU空闲等待时间)
```



#### 系统吞吐量

```
单位时间内完成的作业数量
```



#### 周转时间

```
周转时间 = 作业完成时间 - 作业提交时间
带权周转时间 = 周转时间 / 作业实际运行时间

以上两个可以n个作业求平均值
```



#### 等待时间

```
进程等待处理机的时间之和
作业在就绪队列中等待所花的时间
```



#### 响应时间

```
响应时间 = 系统首次响应 - 用户提交请求
```



<br>



### 2.2.3 调度的实现

#### 调度器（调度程序）

- **排队器** ：维护就绪队列

- **分派器** ：从就绪队列中选进程

- **上下文切换器** ：进程切换时，

    第一次：保存当前进程的上下文到它的PCB，装入分派程序的上下文使得分派程序运行

    第二次：移出分派程序的上下文，将新进程的CPU现场信息装入对应寄存器

上下文切换的时候需要大量load和store寄存器的内容，现在用 **硬件** 来实现

一般有 **两组寄存器（内核用和用户用）** ，上下文切换只需要 **修改指针** 



<br>



#### 调度的时机、切换和过程

**不能调度：**

- **处理中断** 的过程中
- 进程在操作系统 **临界区** （因为加了锁）
- 其他 **完全屏蔽中断的原子操作** 中（加锁、解锁、中断现场保护、恢复等），原子操作连中断都能屏蔽，更别说进程切换了

**应当调度：**

- 满足调度条件，且当前进程不能继续运行（比如等I/O）时
- 中断处理、自陷结束时，返回现场前，如果有 **请求调度标志** ，立刻调度

进程的切换在调度完成后立刻发生，保存当前断点现场（存入当前进程的内核堆栈，并更新堆栈指针），恢复要调度进程的现场（从内核堆栈中），更新空间指针、重设PC等，开始新的进程





<br>



#### 进程调度方式

- **非抢占式：**

    **优** ： 简单、开销少

    适合 **批处理系统** ，不能用与 **实时和分时**

- **抢占式：**

    **优** ： 吞吐量和响应销量好

    优先级、短进程、时间片等





<br>



#### 闲逛进程（idle）

**没有就绪进程时会启动** ，优先级最低

内容是 **测试中断**

只需要CPU不要其他资源， **不会阻塞**



<br>



#### 用户级、内核级线程调度

- **用户级线程调度：**

    内核给 **进程** 时间控制

    线程切换只需要少量机器指令， **开销少**

- **内核级线程调度：**

    内核选择一个特定 **线程** 运行，时间片过会强制挂起该线程

    切换需要完整的上下文切换、修改内存映像、使Cache失效， **开销大**



<br>



### 2.2.4 经典调度算法（重点）

#### 先来先服务FCFS

适用于 **作业** 和 **进程** 调度

每次从就绪队列中选择一个 **最早的** 进程来分配处理机

**特点：**

- **不可剥夺**

- 简单，效率低

- **对短作业不利**

- **有利于CPU繁忙型**



<br>



#### 短作业优先SJF

适用于 **作业** 和 **进程** 调度

每次从就绪队列中选择 **估计运行时间最短** 的作业，调入内存运行

特点：

- 对长作业不利 **饥饿现象**（和死锁不同，死锁是环形等待）
- 没考虑急迫程度
- 估计执行时间不一定可靠
- **平均等待时间、平均周转时间最少**



<br>



#### 时间片轮转

适用于 **进程** 调度，主要用于 **分时系统**

按FCFS组成就绪队列，分配时间片， **当时间片完但进程未完成时，插到就绪队列的最后面，进程完成也会等当前时间片用完再去下个进程**

- **时间片足够大** ： 退化成 **FCFS** 
- **时间片小** ： **频繁切换** ，开销大

时间片的长度应该考虑：

- 响应时间
- 就绪队列长度
- 系统处理能力



<br>



#### 优先级

适用于 **作业** 和 **进程** 调度

用 **优先级（静态或动态）** 描述作业的急迫程度

每次从就绪队列中选择 **优先级最高** 的进程来分配处理机

- 抢占式
- 非抢占式

一般来说：

- 系统进程 > 用户进程
- 交互型进程 > 非交互型
- I/O型 > 计算型，早点开始I/O整体效率高



<br>



#### 高响应比优先

```
响应比Rp = （等待 + 要求服务） / 要求服务
```

- 作业等待时间相同时，短作业响应比高，此时接近于SJF
- 要求服务时间相同时，等待时间越长，响应比越高。此时接近于FCFS
- 长作业的等待时间长，也可以获得处理机， **克服了饥饿现象** 



<br>



#### 多级队列

设置多个队列，每个队列设置不同调度算法，也可自由设计优先级

多处理机中，可以给每个处理机设置一个就绪队列，实现各自不同的调度算法



<br>



#### 多级反馈队列

时间片 + 优先级的进化

动态调整进程优先级和时间片

- 多个就绪队列，又不同的优先级。优先级高的队列时间片小
- 每个队列FCFS，如果完成就走，没完成就一级头出来到二级的尾
- 有更高级的进程要处理机时，交出处理器，然后到当前的队尾



<br>



#### 调度算法的特点图





### 2.2.5 进程切换

- **上下文切换**

    保存当前进程的断点（保存到PCB中），恢复另一个进程的特点

    上下文 ： 当前CPU寄存器和PC的内容

- **上下文切换的消耗**

    要很多CPU时间

    一般是设置寄存器组，只要修改指针就可以了

- **上下文切换和模式切换**

    **上下文切换** ： 进程变了

    **模式切换** ： 用户态和核心态的切换，实际上可能还是同一个进程

- **调度和切换：**

    **调度 ** ：一般说的资源，分配给哪个进程，是决策

    **切换** ：一般说的进程，是执行

    一般先调度再切换



<br>



### 2.2.7 习题



<br>



## 2.3 同步与互斥 
