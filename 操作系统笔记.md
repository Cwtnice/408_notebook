# 第一章 计算机系统概述

## 重点:

以选择题为主

## 1.1 OS基本概念

### 1.1.1 概念、特征

**操作系统** ： 是对计算机资源（软硬）进行管理的系统软件

**操作系统的基本特性 ：** 

- **并发 ：** 

    两个或多个事件在同一时间间隔内发生

    通过 **分时** 实现

    需要硬件支持，例如多流水线、多处理机

- **共享 ：** 

    资源可以供多个并发的进程使用

    **临界资源** ： 一段时间内只允许一个进程访问的资源，只能互斥式共享，例如栈、变量、表格

    允许被同时（微观上还是分时共享的）访问的资源，例如磁盘

- **虚拟：**

    **时分复用技术** ：处理器的分时共享

    **空分复用技术** ：虚拟存储器

- **异步：**

    走走停停，速度不可知

其中并发和共享是最基本的特性，他们互为存在的条件



<br>



### 1.1.3 操作系统的功能

**管理功能：**

- **处理机管理**

    也就是对进程的管理，主要任务是 合理共享

    控制、同步、通信、死锁、处理机调度等

- **存储器管理**

    内存分配和回收、地址映射、内存保护和共享、内存扩充

- **文件管理**

    文件存储空间管理、目录管理、文件读写和保护

- **设备管理**

    缓冲管理、设备分配、设备处理、虚拟设备



<br>



**作为用户和硬件的接口：**

- **命令接口**

    利用操作命令来组织和控制作业执行

    - **联机控制方式（交互式命令接口）** ： 说一句，做一句
    - **脱机控制方式（批处理命令接口）** ： 按清单上的做 

- **程序接口（即系统调用）**

    来请求操作系统服务

    由一组 **系统调用（广义指令）** 组成，系统调用是OS为应用程序使用内核功能提供的接口，只能通过用户程序间接使用



<br>



### 1.1.4 习题

#### 选择题

1. 操作系统与用户通信接口通常不包括：`缓存管理指令`

    ```
    其余选项 shell、命令解释器、广义指令
    
    广义指令就是程序接口
    命令解释器属于命令接口的联机控制方式
    shell是命令解释器
    ```

    

2. 不属于多道程序设计的基本特性是： `顺序性`

    ```
    引入多到程序设计后，失去了封闭性和顺序性
    顺序性是单道程序设计的特点
    ```

    



<br>



## 1.2 OS发展历程

1. **手工操作**

    **无操作系统**

    用户独占全机

    CPU等手工操作，利用不充分

2. **批处理**

    **有操作系统**

    对作业的处理成批进行

    - **单道批** ：内存中只有一道程序

        为了解决人机矛盾和CPU、I/O速度不匹配矛盾产生

        自动性，逐个运行

        **顺序性**

    - **多道批** ：内存中有多道程序

        为了提高资源利用率和系统吞吐率

        **宏观上并行，也就失去了顺序性**

        **微观上串行，轮流占用CPU**

3. **分时操作系统**

    解决了多道批的用户交互差的问题

    将时间分为时间片

    **同时性**

    **交互性**

    **独立性**

    **及时性（时间短，但还是不够短）**

4. **实时操作系统**

    **任务很紧急的情况** 

    - 硬实时：飞行器控制
    - 软实时：飞机订票

    特点是 **及时性** 、 **可靠性**

    



<br>



### 1.2.7 习题

#### 选择题：

1. 【2016】中断技术使得多道批处理系统的I/O设备可与CPU并行工作 `正确`

    ```
    多道批
    当一个程序进入到I/O的时候，CPU不会傻傻的等待，而是去运行另一道程序，此时I/O和CPU并行
    ```

    

2. 【2018】下列关于多任务操作系统的叙述中：

    ```
    具有并发和并行的特点	正确，多任务系统要在同一时间内运行多个应用程序
    需要运行在多CPU的硬件平台上	错误，并不一定要多CPU，单CPU多核也可以
    ```

    



<br>



## 1.3 OS运行环境

### 1.3.1 处理器运行模式

CPU运行两种程序：

- 操作系统的 **内核程序**

    访问需要特权指令，不允许用户直接用

    例如 `I/O` 、 `置中断` 、 `存取保护的寄存器` 、 `写程序状态字寄存器` 等

- 用户的 **应用程序**

    可以用非特权指令，用户直接用，只能访问用户的地址空间

CPU运行状态：

- 用户态（目态），可以通过 **访管/trap/陷入指令** 进入管态（ **所以肯定是在用户态运行！** 
- 核心态（管态）

操作系统内核包括：

1. **时钟管理**

    计时、时间片、时钟中断实现进程切换等等

2. **中断机制**

    保护和恢复现场的功能属于内核

3. **原语**

    最底层，最接近硬件

    **原子性** ，必须一气呵成

4. **系统控制的数据结构及处理**

    例如PCB、FCB、消息队列、缓冲区、内存分配表等



<br>



### 1.3.2 中断和异常

对资源占有权的释放离不开中断





<br>



### 1.3.3 系统调用

系统调用就是提出请求给操作系统

可视为特殊的公共子程序

和资源相关的操作都是通过系统调用，由操作系统代为完成，包括：

- 设备管理
- 文件管理
- 进程控制
- 进程通信
- 内存管理

**执行系统调用的过程主要包括以下操作：**

1. 传递系统调用参数
2. 执行响应的服务程序
3. 执行陷入/访管指令
4. 返回用户态



<br>



### 1.3.4 习题

#### 选择题

1. 核心态到用户态的转换是操作系统完成的，用户态到和心态的转换是 `硬件` 完成的

    ```
    选了中断处理程序，但中断处理程序一般也在核心态执行
    ```

2. 只能在核心态下运行的指令时 `广义指令`

    ```
    广义指令就是系统调用命令
    题目说运行，那么系统调用只能工作在核心态
    用户态下是调用广义指令，然后核心态代为执行
    ```

    

3. CPU处于核心态下可以执行的指令时 `除访管指令的全部指令`

    ```
    和心态可以执行任何指令，但是访管指令时只有用户态能用的
    ```

    

4. 【2012】不可能在用户态发生的事件是 `进程切换`

    ```
    看其他选项：
    系统调用，用户态和核心态都有
    外部中断, 用户态和核心态都有
    缺页，访问虚存时缺页，用户态->内核态
    
    进程切换, 只发生在核心态，因为涉及处理机调度和资源
    ```

    

5. 【2015】处理外部中断时，应该由操作系统保存的是 `通用寄存器的内容`

    ```
    外部中断处理过程
    PC的值由中断隐指令自动保存，通用寄存器的内容由操作系统保存
    ```

    

6. 【2016】访存时缺页属于 `异常` ， 存储保护错属于 `异常`

    ```
    中断和指令无关，异常来自于当前执行的指令
    
    访虚存时缺页和当前执行的指令有关
    ```

    

7. 【2018】定时器产生时间中断后，由时钟中断服务程序更新的部分内容是：

    ```
    内核中时钟变量的值、当前进程占用CPU的时间、当前进程在时间片内的剩余执行时间
    
    和时间有关的都对，全选
    ```

    

8. 【2020】下列和中断相关的操作中，由操作系统完成的是：

    ```
    提供中断服务、初始化中断向量表、保存中断屏蔽字
    
    保存中断程序的断点（PC中的内容）是由硬件自动完成的
    ```

    



<br>



## 1.4 OS结构

#### 分层法

最底层0为硬件，最高层N为用户接口，每层只能调用它的上一层的功能和服务（单项依赖），像个靶子那样的

优点：

- 便于调试和验证
- 易扩充和维护

缺点：

- 合理定义 困难
- 销量较差，要穿很多层的话，都有各自的通信机制



<br>



#### 模块化

按功能划分为若干有一定独立性的模块，各模块通过接口通信（模块-接口法），像是树型结构

好的模块是高内聚，低耦合的

优点：

- 正确性、可理解性、可维护性高
- 各模块一起设计，无法建立在一个已经验证的模块的基础上



<br>



#### 宏内核

也称单内核、大内核

主要功能模块作为一个紧密联系的整体运行在核心态

windows、Android、ios、macos、linux等



<br>



#### 微内核

最基本的功能保留在内核，其余放到用户态执行

移出内核的操作系统代码根据 **分层原理** 划分成若干服务程序，独立运行，借助微内核提供的消息传递机制进行通信

一个模块的崩溃只会使这个模块崩溃，而不会使整个系统崩溃

操作系统分为：

- 微内核：包含硬件处理相关、客户和服务器的通信
- 多个服务器：（我理解为同一个功能，比如进程管理，核心代码在内核，不太核心的放在服务器上）

**采用C/S模式** ， 采用 **机制与策略分离** 的原理来构造OS结构， 机制部分和硬件相关的放入微内核，绝大部分放到微内核外的服务器实现

微内核基本功能：

- 进程（线程）管理
- 低级存储器管理
- 中断和陷入处理

优点：

- 扩展性和灵活性
- 可靠性和安全性
- 可移植性
- 更好地支持分布式

缺点：

- 性能问题，因为要频繁切换用户态和核心态



<br>



#### 外核

保持多个虚拟机彼此不发生冲突

优点：

- 减少了映射层



<br>



## 1.5 OS引导

操作系统也是程序，启动操作系统的过程：

1. **激活CPU**

    CPU读取 **ROM中的boot程序** ，执行BIOS的指令（将指令寄存器设置为BIOS的第一条指令）

2. **硬件自检**

3. **加载带有OS的硬盘**

    BIOS读取Boot Sequence，将控制权交给顺序第一的存储设备，CPU将 该**存储设备引导扇区的内容加载到内存**

4. **加载主引导记录MBR**

    一个一个找引导硬盘， **MBR的作用就是告诉CPU操作系统在哪个硬盘的哪个分区**

5. **扫描硬盘分区表、加载硬盘活动分区**

    MBR中有硬盘分区表，记录了活动分区和非活动分区， **找到含操作系统的活动分区并加载** ，控制权交给活动分区

6. **加载分区引导记录PBR**

    读取活动分区的第一个扇区（称为分区引导记录PBR），为了找到并激活活动分区根目录下用于引导OS的程序（启动管理器）

7. **加载启动管理器**

8. **加载操作系统**





<br>



## 1.6 虚拟机

虚拟机就是隐藏了物理特性，逻辑上的计算机，分为两类：

- **第一类虚拟机管理程序（裸金属架构）** ： **运行在裸机上**

    有多道程序功能，向上层提供若干虚拟机（都是裸机的复制品）

    虚拟机作为用户态的进程，不能执行敏感指令（虚拟机的操作系统以为自己是内核态，实际上使用户态）

    - 如果是 **支持虚拟化的机器** ，虚拟机的操作系统执行敏感指令，虚拟机管理程序能其 **正确执行**， 用户执行，虚拟机管理程序将 **模拟**
    - 不支持虚拟化的机器， **都模拟**

- **第二类虚拟机管理程序（寄居架构）** ： **运行在宿主OS上**

    运行在硬件上的是宿主OS，虚拟机更像一个伪装成有CPU和设备的进程，被称为客户OS

    虚拟磁盘只是宿主OS中的一个文件夹



<br>



### 1.6.2 习题



<br>



# 第二章 进程与线程

## 重点：

## 2.1 进程与线程

### 2.1.1 进程的概念和特征



<br>



### 2.1.2 进程的状态和切换



<br>

