# 第一章 计算机系统概述

## 重点:

以选择题为主

## 1.1 OS基本概念

### 1.1.1 概念、特征

**操作系统** ： 是对计算机资源（软硬）进行管理的系统软件

**操作系统的基本特性 ：** 

- **并发 ：** 

    两个或多个事件在同一时间间隔内发生

    通过 **分时** 实现

    需要硬件支持，例如多流水线、多处理机

- **共享 ：** 

    资源可以供多个并发的进程使用

    **临界资源** ： 一段时间内只允许一个进程访问的资源，只能互斥式共享，例如栈、变量、表格

    允许被同时（微观上还是分时共享的）访问的资源，例如磁盘

- **虚拟：**

    **时分复用技术** ：处理器的分时共享

    **空分复用技术** ：虚拟存储器

- **异步：**

    走走停停，速度不可知

其中并发和共享是最基本的特性，他们互为存在的条件



<br>



### 1.1.3 操作系统的功能

**管理功能：**

- **处理机管理**

    也就是对进程的管理，主要任务是 合理共享

    控制、同步、通信、死锁、处理机调度等

- **存储器管理**

    内存分配和回收、地址映射、内存保护和共享、内存扩充

- **文件管理**

    文件存储空间管理、目录管理、文件读写和保护

- **设备管理**

    缓冲管理、设备分配、设备处理、虚拟设备



<br>



**作为用户和硬件的接口：**

- **命令接口**

    利用操作命令来组织和控制作业执行

    - **联机控制方式（交互式命令接口）** ： 说一句，做一句
    - **脱机控制方式（批处理命令接口）** ： 按清单上的做 

- **程序接口（即系统调用）**

    来请求操作系统服务

    由一组 **系统调用（广义指令）** 组成，系统调用是OS为应用程序使用内核功能提供的接口，只能通过用户程序间接使用



<br>



### 1.1.4 习题

#### 选择题

1. 操作系统与用户通信接口通常不包括：`缓存管理指令`

    ```
    其余选项 shell、命令解释器、广义指令
    
    广义指令就是程序接口
    命令解释器属于命令接口的联机控制方式
    shell是命令解释器
    ```

    

2. 不属于多道程序设计的基本特性是： `顺序性`

    ```
    引入多到程序设计后，失去了封闭性和顺序性
    顺序性是单道程序设计的特点
    ```

    



<br>



## 1.2 OS发展历程

1. **手工操作**

    **无操作系统**

    用户独占全机

    CPU等手工操作，利用不充分

2. **批处理**

    **有操作系统**

    对作业的处理成批进行

    - **单道批** ：内存中只有一道程序

        为了解决人机矛盾和CPU、I/O速度不匹配矛盾产生

        自动性，逐个运行

        **顺序性**

    - **多道批** ：内存中有多道程序

        为了提高资源利用率和系统吞吐率

        **宏观上并行，也就失去了顺序性**

        **微观上串行，轮流占用CPU**

3. **分时操作系统**

    解决了多道批的用户交互差的问题

    将时间分为时间片

    **同时性**

    **交互性**

    **独立性**

    **及时性（时间短，但还是不够短）**

4. **实时操作系统**

    **任务很紧急的情况** 

    - 硬实时：飞行器控制
    - 软实时：飞机订票

    特点是 **及时性** 、 **可靠性**

    



<br>



### 1.2.7 习题

#### 选择题

1. 【2016】中断技术使得多道批处理系统的I/O设备可与CPU并行工作 `正确`

    ```
    多道批
    当一个程序进入到I/O的时候，CPU不会傻傻的等待，而是去运行另一道程序，此时I/O和CPU并行
    ```

    

2. 【2018】下列关于多任务操作系统的叙述中：

    ```
    具有并发和并行的特点	正确，多任务系统要在同一时间内运行多个应用程序
    需要运行在多CPU的硬件平台上	错误，并不一定要多CPU，单CPU多核也可以
    ```

    



<br>



## 1.3 OS运行环境

### 1.3.1 处理器运行模式

CPU运行两种程序：

- 操作系统的 **内核程序**

    访问需要特权指令，不允许用户直接用

    例如 `I/O` 、 `置中断` 、 `存取保护的寄存器` 、 `写程序状态字寄存器` 等

- 用户的 **应用程序**

    可以用非特权指令，用户直接用，只能访问用户的地址空间

CPU运行状态：

- 用户态（目态），可以通过 **访管/trap/陷入指令** 进入管态（ **所以肯定是在用户态运行！** 
- 核心态（管态）

操作系统内核包括：

1. **时钟管理**

    计时、时间片、时钟中断实现进程切换等等

2. **中断机制**

    保护和恢复现场的功能属于内核

3. **原语**

    最底层，最接近硬件

    **原子性** ，必须一气呵成

4. **系统控制的数据结构及处理**

    例如PCB、FCB、消息队列、缓冲区、内存分配表等



<br>



### 1.3.2 中断和异常

对资源占有权的释放离不开中断





<br>



### 1.3.3 系统调用

系统调用就是提出请求给操作系统

可视为特殊的公共子程序

和资源相关的操作都是通过系统调用，由操作系统代为完成，包括：

- 设备管理
- 文件管理
- 进程控制
- 进程通信
- 内存管理

**执行系统调用的过程主要包括以下操作：**

1. 传递系统调用参数
2. 执行响应的服务程序
3. 执行陷入/访管指令
4. 返回用户态



<br>



### 1.3.4 习题

#### 选择题

1. 核心态到用户态的转换是操作系统完成的，用户态到和心态的转换是 `硬件` 完成的

    ```
    选了中断处理程序，但中断处理程序一般也在核心态执行
    ```

2. 只能在核心态下运行的指令时 `广义指令`

    ```
    广义指令就是系统调用命令
    题目说运行，那么系统调用只能工作在核心态
    用户态下是调用广义指令，然后核心态代为执行
    ```

    

3. CPU处于核心态下可以执行的指令时 `除访管指令的全部指令`

    ```
    和心态可以执行任何指令，但是访管指令时只有用户态能用的
    ```

    

4. 【2012】不可能在用户态发生的事件是 `进程切换`

    ```
    看其他选项：
    系统调用，用户态和核心态都有
    外部中断, 用户态和核心态都有
    缺页，访问虚存时缺页，用户态->内核态
    
    进程切换, 只发生在核心态，因为涉及处理机调度和资源
    ```

    

5. 【2015】处理外部中断时，应该由操作系统保存的是 `通用寄存器的内容`

    ```
    外部中断处理过程
    PC的值由中断隐指令自动保存，通用寄存器的内容由操作系统保存
    ```

    

6. 【2016】访存时缺页属于 `异常` ， 存储保护错属于 `异常`

    ```
    中断和指令无关，异常来自于当前执行的指令
    
    访虚存时缺页和当前执行的指令有关
    ```

    

7. 【2018】定时器产生时间中断后，由时钟中断服务程序更新的部分内容是：

    ```
    内核中时钟变量的值、当前进程占用CPU的时间、当前进程在时间片内的剩余执行时间
    
    和时间有关的都对，全选
    ```

    

8. 【2020】下列和中断相关的操作中，由操作系统完成的是：

    ```
    提供中断服务、初始化中断向量表、保存中断屏蔽字
    
    保存中断程序的断点（PC中的内容）是由硬件自动完成的
    ```

    



<br>



## 1.4 OS结构

#### 分层法

最底层0为硬件，最高层N为用户接口，每层只能调用它的上一层的功能和服务（单项依赖），像个靶子那样的

优点：

- 便于调试和验证
- 易扩充和维护

缺点：

- 合理定义 困难
- 销量较差，要穿很多层的话，都有各自的通信机制



<br>



#### 模块化

按功能划分为若干有一定独立性的模块，各模块通过接口通信（模块-接口法），像是树型结构

好的模块是高内聚，低耦合的

优点：

- 正确性、可理解性、可维护性高
- 各模块一起设计，无法建立在一个已经验证的模块的基础上



<br>



#### 宏内核

也称单内核、大内核

主要功能模块作为一个紧密联系的整体运行在核心态

windows、Android、ios、macos、linux等



<br>



#### 微内核

最基本的功能保留在内核，其余放到用户态执行

移出内核的操作系统代码根据 **分层原理** 划分成若干服务程序，独立运行，借助微内核提供的消息传递机制进行通信

一个模块的崩溃只会使这个模块崩溃，而不会使整个系统崩溃

操作系统分为：

- 微内核：包含硬件处理相关、客户和服务器的通信
- 多个服务器：（我理解为同一个功能，比如进程管理，核心代码在内核，不太核心的放在服务器上）

**采用C/S模式** 

采用 **机制与策略分离** 的原理来构造OS结构， 机制部分和硬件相关的放入微内核，绝大部分放到微内核外的服务器实现

微内核基本功能：

- 进程（线程）管理
- 低级存储器管理
- 中断和陷入处理

优点：

- 扩展性和灵活性
- 可靠性和安全性
- 可移植性
- 更好地支持分布式

缺点：

- 性能问题，因为要频繁切换用户态和核心态， **不够高效** 



<br>



#### 外核

保持多个虚拟机彼此不发生冲突

优点：

- 减少了映射层



<br>



## 1.5 OS引导

操作系统也是程序，启动操作系统的过程：

1. **激活CPU**

    CPU读取 **ROM中的boot程序** ，执行BIOS的指令（将指令寄存器设置为BIOS的第一条指令）

2. **硬件自检**

3. **加载带有OS的硬盘**

    BIOS读取Boot Sequence，将控制权交给顺序第一的存储设备，CPU将 该**存储设备引导扇区的内容加载到内存**

4. **加载主引导记录MBR**

    一个一个找引导硬盘， **MBR的作用就是告诉CPU操作系统在哪个硬盘的哪个分区**

5. **扫描硬盘分区表、加载硬盘活动分区**

    MBR中有硬盘分区表，记录了活动分区和非活动分区， **找到含操作系统的活动分区并加载** ，控制权交给活动分区

6. **加载分区引导记录PBR**

    读取活动分区的第一个扇区（称为分区引导记录PBR），为了找到并激活活动分区根目录下用于引导OS的程序（启动管理器）

7. **加载启动管理器**

8. **加载操作系统**





<br>



## 1.6 虚拟机

虚拟机就是隐藏了物理特性，逻辑上的计算机，分为两类：

- **第一类虚拟机管理程序（裸金属架构）** ： **运行在裸机上**

    有多道程序功能，向上层提供若干虚拟机（都是裸机的复制品）

    虚拟机作为用户态的进程，不能执行敏感指令（虚拟机的操作系统以为自己是内核态，实际上使用户态）

    - 如果是 **支持虚拟化的机器** ，虚拟机的操作系统执行敏感指令，虚拟机管理程序能其 **正确执行**， 用户执行，虚拟机管理程序将 **模拟**
    - 不支持虚拟化的机器， **都模拟**

- **第二类虚拟机管理程序（寄居架构）** ： **运行在宿主OS上**

    运行在硬件上的是宿主OS，虚拟机更像一个伪装成有CPU和设备的进程，被称为客户OS

    虚拟磁盘只是宿主OS中的一个文件夹
    
    **VMware**

注 ： 软件、硬件都可以实现虚拟机



<br>



### 1.6.2 习题

#### 选择题

1. 采用微内核结构，不宜放在微内核中的有：

    ```
    文件系统服务，在文件服务器中
    
    其余选项
    进程间通信机制，最频繁，放内核
    低级I/O，和硬件相关，放内核
    低级进程管理和调度， 属于调度功能的机制部分，放内核
    中断和陷入处理，放内核
    ```

    

2. 操作系统的引导程序位于 `硬盘`

    ```
    装有操作系统的硬盘的活动分区的引导扇面中的引导程序（也就是启动管理器），用于引导操作系统
    
    另外还有用于启动设备的引导程序，位于ROM中的自举程序（BIOS的组成部分）
    ```

    

3. 计算机启动的过程是：

    ```
    1. CPU加电
    2. 执行JMP指令跳转到BIOS
    3. 等级BIOS中断例程入口地址
    4. 硬件自检
    5. 进行操作系统引导
    
    关键：先BIOS再自检
    ```

    

4. 多台虚拟机可同时运行在同一物理机器上，实现了真正的并行 `错误`

    ```
    实现了真正并行的是多核处理机
    多个虚拟机就相当于多个程序
    ```



<br>

### 并发性和并行性

- 并发：同一个时间间隔内发生，微观只有一道，宏观看有多道
- 并行：同一时刻有多个同时发生，例如多处理器

### 特权指令和非特权指令

- 核心态：能运行除访管指令外的全部指令
- 用户态：只能运行非特权指令

### 访管指令

访管指令能产生一个访管中断，将操作系统转为核心态，访管中断处理程序将按系统调用的操作数和参数转移到相应的例行子程序，完成后回到断点



# 第二章 进程与线程

## 重点：

进程必考

- 选择题

- 综合题：信号量机制实现同步和互斥

## 2.1 进程与线程

### 2.1.1 进程的概念和特征

进程（动态的） ： 程序实体的运行过程，系统进行资源分配的独立单位，动态，为了实现OS的并发性和共享性引入的概念

进程控制块PCB ： 用来描述和控制进程，是进程存在的唯一标志

进程实体（进程映像，静态的） ：

- 程序段
- 相关数据
- PCB

进程的特征：

- 动态性
- 并发性
- 独立性
- 异步性



<br>



### 2.1.2  进程的状态与转换（重要）

进程的状态（前三种是基本状态）：

- **运行态**

- **就绪态：**

    进程获得了 **除处理机外的一切资源** ，就绪队列

- **阻塞态（等待态）：**

    等待某一事件（等待非处理机的资源，等待I/O等）而暂停运行，有处理器也不能运行。根据原因放在多个阻塞队列

    **只能由运行态进入**

- **创建态：**

    创建的过程中，结束到就绪态

    申请空白PCB、写入控制和管理进程的信息、分配资源、转入就绪队列

    如果资源不能得到满足，仍然处于创建态

- **结束态：**

    先设为结束态，再回收资源

补充：

- 运行态到阻塞态（比如等待I/O）： **主动**
- 阻塞态到就绪态（资源到手)  ： **被动**

![第二章_进程5种状态的切换](assets/操作系统笔记/第二章_进程5种状态的切换.png)



<br>



### 2.1.3  进程的组织（先跳过）



<br>



### 2.1.4  进程控制（先跳过）



<br>



### 2.1.5  进程的通信

PV操作属于低级通信，高级通信有：

- 共享存储
- 消息传递
- 管道通信



<br>



### 2.1.6 线程和多线程模型

引入进程的目的 ： 为了更好地实现多道程序的并发执行，提高资源利用率和系统吞吐量

引入线程的目的 ： 减少程序在并发执行时付出的时空开销，提高并发性能

线程 ： 

- 系统调度的基本单位
- 同个进程的所有线程共享全部资源
- 线程切换开销少，同一个进程内的线程切换不会切换进程
- 支持多处理机系统

线程的状态：

- 运行态
- 就绪态
- 阻塞态



<br>



#### 用户级线程ULT（线程库支持的线程）

用户在用户空间用 线程库 编写的多线程程序

**内核意识不到线程的存在**

调度仍然以 **进程** 为单位

**优点：**

- 线程切换不需要切换到内核空间，开销少
- 调度算法可以根据情况设置
- 和操作系统平台无关

**缺点：**

- 一个线程阻塞，同个进程的所有线程都阻塞
-  **只有一个线程能用处理机** ， 不能发挥多处理机的优势

**线程库：** 分为有无内核支持两种

-  Pthreads
- Windows API
- Java 线程 API



<br>



#### 内核级线程KLT（内核支持的线程）

在内核的支持下运行，内核空间为每个线程设置一个线程控制块

**优点：**

- 能用多处理机
- 一个阻塞，不影响其他
- 线程切换快，开销少
- 内核本身也可用多线程技术

**缺点：**

- 统一进程中切换线程， **需要从用户态切换到核心态** （用户程序的线程在用户态，线程管理在核心态），系统开销大



<br>



#### 组合方式

用户级线程通过 **时分复用内核级线程** 实现

有ULT和KLT的优点，克服了缺点



<br>



#### 多线程模型

- **多对一**

    多个用户线程映射到一个内核线程

    **优** ：销量高

    **缺** ： 一个阻塞其他也阻塞，不能用多处理机 

- **一对一**

    **优** ： 一个阻塞，运行调度另一个运行，并发能力强

    **缺** ： 每有一个用户线程就要创建一个内核线程，开销大

- **多对多**



### 2.1.8 习题





<br>



## 2.2 处理机调度

### 2.2.1 调度的概念



<br>



### 2.2.2 调度的目标



<br>



### 2.2.3 调度的实现



<br>



### 2.2.4 经典调度算法（重点）



<br>



### 2.2.5 进程切换



<br>



### 2.2.7 习题



<br>



## 2.3 同步与互斥 
